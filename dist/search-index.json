[
  {
    "id": "01-getting-started-first-steps",
    "title": "第一步：创建你的第一个项目",
    "content": "\n# 第一步：创建你的第一个项目\n\n现在你已经安装好了 Claude Code，让我们通过一个简单的示例来体验它的强大功能。\n\n## 创建新项目\n\n### 1. 打开 Claude Code\n\n启动 Claude Code 应用程序，你会看到欢迎界面。\n\n### 2. 创建项目文件夹\n\n有两种方式创建新项目：\n\n**方式一：通过界面**\n1. 点击\"文件\" > \"打开文件夹\"\n2. 选择或创建一个新文件夹（例如 `my-first-project`）\n3. 点击\"选择文件夹\"\n\n**方式二：通过命令行**\n```bash\n# 创建项目文件夹\nmkdir my-first-project\ncd my-first-project\n\n# 使用 Claude Code 打开\nclaude .\n```\n\n## 第一个 Python 示例\n\n让我们创建一个简单的 Python 程序，体验 Claude Code 的代码补全和 AI 助手功能。\n\n### 1. 创建 Python 文件\n\n1. 在左侧文件浏览器中，点击\"新建文件\"图标\n2. 输入文件名：`hello.py`\n3. 按 Enter 键创建文件\n\n### 2. 使用代码补全\n\n在 `hello.py` 文件中，开始输入以下代码：\n\n```python\n# 这是我的第一个 Python 程序\ndef greet(name):\n    \"\"\"向用户打招呼\"\"\"\n    message = f\"你好，{name}！欢迎使用 Claude Code。\"\n    return message\n\n# 主程序\nif __name__ == \"__main__\":\n    user_name = input(\"请输入你的名字：\")\n    greeting = greet(user_name)\n    print(greeting)\n```\n\n**体验智能补全：**\n- 当你输入 `def` 时，Claude Code 会自动建议函数定义\n- 输入 `f\"` 时，会提示 f-string 格式\n- 输入 `if __name__` 时，会自动补全完整的主程序模板\n\n### 3. 运行程序\n\n在终端中运行你的第一个程序：\n\n```bash\npython hello.py\n```\n\n输入你的名字，程序会向你打招呼！\n\n## 使用 AI 助手\n\nClaude Code 最强大的功能之一是 AI 助手。让我们用它来改进我们的程序。\n\n### 1. 打开 Chat 面板\n\n- 点击左侧的聊天图标，或\n- 使用快捷键 `Ctrl+L`（Windows/Linux）或 `Cmd+L`（macOS）\n\n### 2. 与 AI 对话\n\n在聊天框中输入：\n\n```\n请帮我改进这个程序，添加以下功能：\n1. 支持多种语言的问候（中文、英文、日文）\n2. 添加错误处理\n3. 让代码更加优雅\n```\n\nAI 助手会分析你的代码，并提供改进建议。你可以直接应用这些建议，或者继续讨论。\n\n### 3. 应用建议\n\nAI 可能会建议类似这样的改进代码：\n\n```python\n# 改进后的多语言问候程序\ndef greet(name, language=\"zh\"):\n    \"\"\"\n    向用户打招呼\n    \n    参数:\n        name (str): 用户名字\n        language (str): 语言代码 ('zh', 'en', 'ja')\n    \n    返回:\n        str: 问候消息\n    \"\"\"\n    greetings = {\n        \"zh\": f\"你好，{name}！欢迎使用 Claude Code。\",\n        \"en\": f\"Hello, {name}! Welcome to Claude Code.\",\n        \"ja\": f\"こんにちは、{name}さん！Claude Code へようこそ。\"\n    }\n    \n    return greetings.get(language, greetings[\"zh\"])\n\ndef get_user_input(prompt):\n    \"\"\"安全地获取用户输入\"\"\"\n    try:\n        return input(prompt).strip()\n    except (KeyboardInterrupt, EOFError):\n        print(\"\\n程序已退出。\")\n        return None\n\ndef main():\n    \"\"\"主程序\"\"\"\n    print(\"=== 多语言问候程序 ===\")\n    \n    # 获取用户名\n    user_name = get_user_input(\"请输入你的名字：\")\n    if not user_name:\n        return\n    \n    # 选择语言\n    print(\"\\n选择语言：\")\n    print(\"1. 中文 (zh)\")\n    print(\"2. English (en)\")\n    print(\"3. 日本語 (ja)\")\n    \n    lang_choice = get_user_input(\"请输入选项 (1-3)：\")\n    \n    # 语言映射\n    lang_map = {\"1\": \"zh\", \"2\": \"en\", \"3\": \"ja\"}\n    language = lang_map.get(lang_choice, \"zh\")\n    \n    # 显示问候\n    greeting = greet(user_name, language)\n    print(f\"\\n{greeting}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n点击代码块旁边的\"应用\"按钮，AI 会自动更新你的文件。\n\n## 第一个 JavaScript 示例\n\n让我们再创建一个 JavaScript 示例，体验不同语言的开发体验。\n\n### 1. 创建 HTML 和 JavaScript 文件\n\n创建 `index.html`：\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>我的第一个网页</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 600px;\n            margin: 50px auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            background: white;\n            padding: 30px;\n            border-radius: 10px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        button {\n            background-color: #4CAF50;\n            color: white;\n            padding: 10px 20px;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        #output {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #e8f5e9;\n            border-radius: 5px;\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>欢迎使用 Claude Code</h1>\n        <p>点击按钮查看当前时间：</p>\n        <button onclick=\"showTime()\">显示时间</button>\n        <div id=\"output\"></div>\n    </div>\n    <script src=\"script.js\"></script>\n</body>\n</html>\n```\n\n创建 `script.js`：\n\n```javascript\n// 显示当前时间的函数\nfunction showTime() {\n    const now = new Date();\n    const timeString = now.toLocaleString('zh-CN', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit'\n    });\n    \n    const output = document.getElementById('output');\n    output.textContent = `当前时间：${timeString}`;\n    output.style.display = 'block';\n    \n    // 添加动画效果\n    output.style.animation = 'fadeIn 0.5s';\n}\n\n// 添加 CSS 动画\nconst style = document.createElement('style');\nst\nyle.textContent = `\n    @keyframes fadeIn {\n        from { opacity: 0; transform: translateY(-10px); }\n        to { opacity: 1; transform: translateY(0); }\n    }\n`;\ndocument.head.appendChild(style);\n\n// 页面加载完成后的初始化\ndocument.addEventListener('DOMContentLoaded', function() {\n    console.log('Claude Code 示例页面已加载');\n    \n    // 添加键盘事件监听\n    document.addEventListener('keydown', function(event) {\n        if (event.key === 'Enter' || event.key === ' ') {\n            showTime();",
    "chapterId": "01-getting-started",
    "tags": [
      "入门",
      "示例",
      "实践",
      "代码示例"
    ],
    "level": "beginner"
  },
  {
    "id": "01-getting-started-installation",
    "title": "安装 Claude Code",
    "content": "\n# 安装 Claude Code\n\n本指南将帮助你在不同操作系统上安装 Claude Code，并完成基本配置。\n\n## 系统要求\n\n在开始安装之前，请确保你的系统满足以下要求：\n\n- **操作系统**：Windows 10/11、macOS 10.15+、或主流 Linux 发行版\n- **内存**：至少 4GB RAM（推荐 8GB 或更多）\n- **磁盘空间**：至少 500MB 可用空间\n- **网络连接**：需要互联网连接以下载和激活\n\n## Windows 安装步骤\n\n### 1. 下载安装程序\n\n访问 [Claude Code 官方网站](https://code.claude.com)，点击\"下载\"按钮，选择 Windows 版本。\n\n### 2. 运行安装程序\n\n1. 双击下载的 `.exe` 文件\n2. 如果出现安全提示，点击\"运行\"\n3. 选择安装路径（默认为 `C:\\Program Files\\Claude Code`）\n4. 点击\"安装\"按钮\n\n### 3. 完成安装\n\n安装完成后，你可以：\n- 从开始菜单启动 Claude Code\n- 在桌面上找到快捷方式\n- 右键点击文件夹选择\"使用 Claude Code 打开\"\n\n### Windows 常见问题\n\n**问题：安装时提示\"需要管理员权限\"**\n- 解决方案：右键点击安装程序，选择\"以管理员身份运行\"\n\n**问题：防火墙阻止连接**\n- 解决方案：在 Windows 防火墙设置中允许 Claude Code 访问网络\n\n## macOS 安装步骤\n\n### 1. 下载安装包\n\n访问官方网站下载 macOS 版本（`.dmg` 文件）。\n\n### 2. 安装应用\n\n1. 双击下载的 `.dmg` 文件\n2. 将 Claude Code 图标拖动到\"应用程序\"文件夹\n3. 等待复制完成\n\n### 3. 首次启动\n\n1. 打开\"应用程序\"文件夹\n2. 双击 Claude Code 图标\n3. 如果出现\"无法打开，因为它来自身份不明的开发者\"提示：\n   - 打开\"系统偏好设置\" > \"安全性与隐私\"\n   - 点击\"仍要打开\"按钮\n\n### 使用 Homebrew 安装（推荐）\n\n如果你已经安装了 Homebrew，可以使用命令行快速安装：\n\n```bash\n# 添加 Claude Code tap\nbrew tap claude/code\n\n# 安装 Claude Code\nbrew install claude-code\n\n# 启动应用\nclaude-code\n```\n\n### macOS 常见问题\n\n**问题：无法打开应用**\n- 解决方案：在终端运行 `xattr -cr /Applications/Claude\\ Code.app`\n\n**问题：命令行工具未找到**\n- 解决方案：在 Claude Code 中打开命令面板（Cmd+Shift+P），搜索\"Install 'claude' command\"\n\n## Linux 安装步骤\n\n### Ubuntu/Debian 系统\n\n使用 APT 包管理器安装：\n\n```bash\n# 添加 Claude Code 仓库\ncurl -fsSL https://code.claude.com/keys/linux.asc | sudo gpg --dearmor -o /usr/share/keyrings/claude-code.gpg\n\necho \"deb [signed-by=/usr/share/keyrings/claude-code.gpg] https://code.claude.com/repos/apt stable main\" | sudo tee /etc/apt/sources.list.d/claude-code.list\n\n# 更新包列表\nsudo apt update\n\n# 安装 Claude Code\nsudo apt install claude-code\n```\n\n### Fedora/RHEL 系统\n\n使用 DNF 包管理器安装：\n\n```bash\n# 添加仓库\nsudo rpm --import https://code.claude.com/keys/linux.asc\n\nsudo tee /etc/yum.repos.d/claude-code.repo <<EOF\n[claude-code]\nname=Claude Code Repository\nbaseurl=https://code.claude.com/repos/rpm\nenabled=1\ngpgcheck=1\ngpgkey=https://code.claude.com/keys/linux.asc\nEOF\n\n# 安装\nsudo dnf install claude-code\n```\n\n### Arch Linux\n\n使用 AUR 安装：\n\n```bash\n# 使用 yay\nyay -S claude-code\n\n# 或使用 paru\nparu -S claude-code\n```\n\n### 通用 Linux（AppImage）\n\n如果你的发行版不在上述列表中，可以下载 AppImage 版本：\n\n```bash\n# 下载 AppImage\nwget https://code.claude.com/download/linux/claude-code.AppImage\n\n# 添加执行权限\nchmod +x claude-code.AppImage\n\n# 运行\n./claude-code.AppImage\n```\n\n### Linux 常见问题\n\n**问题：缺少依赖库**\n- 解决方案：安装必要的依赖 `sudo apt install libgtk-3-0 libnotify4 libnss3`\n\n**问题：无法启动图形界面**\n- 解决方案：确保已安装 X11 或 Wayland 显示服务器\n\n## 首次配置\n\n安装完成后，首次启动 Claude Code 时需要进行一些基本配置：\n\n### 1. 登录账户\n\n1. 启动 Claude Code\n2. 点击\"登录\"按钮\n3. 使用你的 Anthropic 账户登录\n4. 如果没有账户，点击\"注册\"创建新账户\n\n### 2. 选择主题\n\n根据个人喜好选择明亮或暗黑主题：\n- 点击左下角的设置图标\n- 选择\"主题\" > \"颜色主题\"\n- 选择你喜欢的主题\n\n### 3. 配置快捷键\n\nClaude Code 提供了丰富的快捷键，你可以根据习惯自定义：\n- 打开命令面板：`Ctrl+Shift+P`（Windows/Linux）或 `Cmd+Shift+P`（macOS）\n- 搜索\"键盘快捷键\"\n- 自定义你常用的快捷键\n\n### 4. 安装扩展（可选）\n\n根据你的编程语言和工作流程，可以安装相应的扩展：\n- 点击左侧的扩展图标\n- 搜索你需要的扩展（如 Python、JavaScript、Git 等）\n- 点击\"安装\"按钮\n\n## 验证安装\n\n要确认 Claude Code 已正确安装，可以：\n\n1. 打开终端或命令提示符\n2. 运行命令：`claude --version`\n3. 如果显示版本号，说明安装成功\n\n## 更新 Claude Code\n\nClaude Code 会自动检查更新，当有新版本时会提示你更新。你也可以手动检查更新：\n\n- 打开命令面板（`Ctrl+Shift+P` 或 `Cmd+Shift+P`）\n- 搜索\"检查更新\"\n- 如果有更新，点击\"立即更新\"\n\n## 下一步\n\n恭喜你成功安装了 Claude Code！现在你可以继续学习如何使用它来提升编程效率。\n\n在下一章节中，我们将创建第一个项目，体验 Claude Code 的强大功能。\n",
    "chapterId": "01-getting-started",
    "tags": [
      "安装",
      "配置",
      "入门",
      "系统要求"
    ],
    "level": "beginner"
  },
  {
    "id": "01-getting-started-introduction",
    "title": "Claude Code 简介",
    "content": "\n# Claude Code 简介\n\n欢迎来到 Claude Code 教程！本章节将帮助你全面了解 Claude Code 的功能、优势和应用场景。\n\n## 什么是 Claude Code？\n\nClaude Code 是由 Anthropic 开发的一款革命性的 AI 辅助编程工具。它集成了最先进的大语言模型技术，能够理解你的编程意图，提供智能的代码建议、实时协助和深度的代码分析。与传统的代码编辑器和 IDE 不同，Claude Code 不仅仅是一个编辑工具，更是一个能够理解代码逻辑、参与编程决策的智能伙伴。\n\n### 核心理念\n\nClaude Code 的设计理念是\"增强而非替代\"。它的目标不是替代程序员，而是通过 AI 的力量，让程序员能够：\n\n- 专注于解决问题的核心逻辑\n- 减少重复性和机械性的编码工作\n- 快速学习新的编程语言和框架\n- 提高代码质量和开发效率\n\n## 核心功能\n\n### 1. 智能代码补全（Inline Suggestions）\n\nClaude Code 提供上下文感知的代码补全，这不是简单的关键字匹配，而是真正的智能推理：\n\n- **多行补全**：不仅补全单个词，还能生成完整的函数、类甚至代码块\n- **上下文理解**：分析你的代码结构、变量名、注释，推断你的编程意图\n- **实时响应**：在你输入时即时提供建议，无需等待\n- **多语言支持**：支持 Python、JavaScript、TypeScript、Java、Go、Rust 等 50+ 种编程语言\n\n**示例**：当你输入函数名 `calculateUserAge` 时，Claude Code 不仅会补全函数签名，还会根据函数名推断出完整的实现逻辑。\n\n### 2. 对话式编程（Chat）\n\n通过自然语言与 AI 助手进行实时对话，就像与一位经验丰富的程序员结对编程：\n\n- **问题解答**：提出任何编程问题，获得详细的解释和代码示例\n- **代码审查**：让 AI 审查你的代码，指出潜在问题和改进建议\n- **重构协助**：帮助你重构代码，提高代码质量和可维护性\n- **学习辅助**：学习新的编程语言、框架或设计模式\n- **调试帮助**：快速定位和修复代码中的 bug\n\n**示例**：你可以说\"帮我创建一个 React 组件，显示用户列表，支持搜索和分页\"，Claude Code 会生成完整的、生产级别的代码实现。\n\n### 3. 代码理解与分析\n\n快速理解陌生的代码库和复杂的逻辑：\n\n- **代码解释**：选中任何代码，AI 会详细解释其功能和工作原理\n- **架构分析**：理解项目的整体结构和各模块之间的关系\n- **性能分析**：识别代码中的性能瓶颈和优化机会\n- **文档生成**：自动生成代码注释和 API 文档\n\n### 4. 高级功能\n\n- **Specs 工作流**：使用结构化的规范文档来指导 AI 完成复杂的开发任务\n- **Agent Hooks**：自动化重复性的开发工作流程\n- **Steering 配置**：为团队定制 AI 的行为和建议\n- **MCP 集成**：连接外部工具和服务，扩展 Claude Code 的能力\n\n## 使用场景\n\n### 场景 1：快速原型开发\n\n使用 Claude Code 的代码补全和对话功能，快速将想法转化为可运行的代码。从概念到原型只需几分钟。\n\n### 场景 2：学习新技术\n\n学习新的编程语言或框架时，Claude Code 可以：\n- 解释语言特性和最佳实践\n- 提供常见模式的代码示例\n- 帮助你理解官方文档中的复杂概念\n\n### 场景 3：代码重构和优化\n\n对于遗留代码或性能不佳的代码：\n- AI 可以分析代码并提出改进方案\n- 帮助你逐步重构代码\n- 确保重构过程中不引入新的 bug\n\n### 场景 4：团队协作\n\n在团队开发中：\n- 新成员可以快速理解项目代码\n- 代码审查变得更加高效\n- 知识共享和最佳实践传播更容易\n\n### 场景 5：全栈开发\n\n从前端到后端，Claude Code 支持所有主流技术栈：\n- 前端：React、Vue、Angular、Svelte 等\n- 后端：Node.js、Python、Java、Go 等\n- 数据库：SQL、MongoDB、Redis 等\n- 基础设施：Docker、Kubernetes、Terraform 等\n\n## Claude Code 的优势\n\n### 1. 提高开发效率\n\n研究表明，使用 Claude Code 的开发者能够：\n- 减少 30-50% 的编码时间\n- 减少 40% 的调试时间\n- 提高 25% 的代码质量\n\n### 2. 降低学习曲线\n\n- 快速学习新的编程语言和框架\n- 理解复杂的代码库变得容易\n- 减少查阅文档的时间\n\n### 3. 改进代码质量\n\n- 遵循最佳实践和设计模式\n- 自动检测潜在的 bug 和性能问题\n- 生成更易维护的代码\n\n### 4. 增强创意和创新\n\n- 专注于解决问题的核心逻辑\n- 快速尝试不同的实现方案\n- 更多时间用于架构设计和创新\n\n## 技术特点\n\n### 智能模型\n\nClaude Code 基于 Anthropic 的最新 Claude 模型，具有：\n- 强大的代码理解能力\n- 支持超长上下文（100K+ tokens）\n- 多语言和多领域的知识\n\n### 隐私和安全\n\n- 你的代码不会被用于训练模型\n- 支持本地部署选项\n- 企业级的安全和合规性\n\n### 实时性能\n\n- 毫秒级的响应时间\n- 支持离线工作（某些功能）\n- 自动同步和备份\n\n## 适用人群\n\nClaude Code 适合所有类型的开发者：\n\n- **初学者**：快速学习编程，减少挫折感\n- **中级开发者**：提高开发效率，学习最佳实践\n- **高级开发者**：处理复杂问题，专注于架构设计\n- **团队领导**：提高团队整体效率，统一代码标准\n\n## 开始你的 Claude Code 之旅\n\n现在你已经了解了 Claude Code 的强大功能和优势，准备好开始学习如何使用它了吗？\n\n在下一章节中，我们将学习如何在你的系统上安装 Claude Code，并进行基本配置。无论你使用 Windows、macOS 还是 Linux，我们都会提供详细的步骤指导。\n\n## 关键要点总结\n\n- ✅ Claude Code 是一个 AI 辅助编程工具，不是代码生成器\n- ✅ 它提供智能补全、对话式编程和代码分析功能\n- ✅ 适用于各种编程语言和开发场景\n- ✅ 能够显著提高开发效率和代码质量\n- ✅ 保护你的隐私和代码安全\n\n让我们继续下一章节，开始安装和配置 Claude Code！\n",
    "chapterId": "01-getting-started",
    "tags": [
      "简介",
      "概述",
      "核心概念"
    ],
    "level": "beginner"
  },
  {
    "id": "02-basics-chat",
    "title": "对话式编程",
    "content": "\n# 对话式编程\n\n对话式编程是 Claude Code 的另一个核心功能，它允许你通过自然语言与 AI 进行交流，就像与一位经验丰富的程序员结对编程一样。你可以提出问题、请求代码实现、寻求调试帮助，甚至讨论架构设计。\n\n## 什么是对话式编程？\n\n对话式编程（Chat）是一种全新的编程方式。你不需要记住复杂的 API 文档或搜索 Stack Overflow，只需用自然语言描述你的需求，AI 就能理解并提供帮助。这种方式特别适合：\n\n- 学习新的编程语言或框架\n- 调试复杂的代码问题\n- 重构现有代码\n- 探索不同的实现方案\n- 理解陌生的代码库\n\n## 如何开始对话\n\n### 打开 Chat 面板\n\n有多种方式可以打开 Chat 面板：\n\n1. **快捷键**：按 `Ctrl/Cmd + Shift + C`\n2. **命令面板**：按 `Ctrl/Cmd + Shift + P`，输入 \"Claude Code: Open Chat\"\n3. **侧边栏**：点击左侧活动栏的 Claude Code 图标\n\n### 基本对话流程\n\n1. **描述需求**：用自然语言清晰地描述你想要做什么\n2. **提供上下文**：如果需要，选中相关代码或提及文件名\n3. **接收回复**：AI 会提供解释、代码示例或建议\n4. **迭代优化**：根据回复继续提问或请求修改\n5. **应用代码**：直接将 AI 生成的代码应用到你的项目中\n\n## 对话工作流程\n\n### 工作流程 1：实现新功能\n\n```\n你：我需要创建一个 React 组件，显示用户列表，支持搜索和分页\n\nAI：我来帮你创建这个组件。首先，让我们定义组件的结构...\n\n[AI 提供完整的代码实现]\n\n你：可以添加加载状态和错误处理吗？\n\nAI：当然，我会添加这些功能...\n\n[AI 更新代码，添加加载和错误处理]\n```\n\n### 工作流程 2：调试问题\n\n```\n你：这段代码有 bug，数组越界错误\n[选中有问题的代码]\n\nAI：我看到问题了。在第 15 行，循环条件应该是 i < array.length 而不是 i <= array.length...\n\n你：修复后还是有问题，能帮我检查一下吗？\n\nAI：让我仔细看看。还有一个问题在第 23 行...\n```\n\n### 工作流程 3：代码重构\n\n```\n你：这个函数太长了，能帮我重构一下吗？\n[选中需要重构的函数]\n\nAI：这个函数确实可以拆分成几个更小的函数。我建议...\n\n[AI 提供重构后的代码]\n\n你：看起来不错，但能保持原有的函数签名吗？\n\nAI：没问题，我会保持接口不变...\n```\n\n## 实用技巧\n\n### 1. 提供清晰的上下文\n\n选中相关代码后再提问，AI 能更准确地理解你的需求：\n\n```javascript\n// 选中这段代码\nfunction processData(data) {\n  // 复杂的处理逻辑\n  return result;\n}\n\n// 然后在 Chat 中问：\n// \"这个函数的时间复杂度是多少？有优化空间吗？\"\n```\n\n### 2. 使用 @ 符号引用文件\n\n在对话中使用 `@` 符号可以引用特定文件：\n\n```\n你：@UserService.ts 这个文件中的 getUserById 方法有什么问题？\n\nAI：让我检查 UserService.ts 文件...\n```\n\n### 3. 分步骤提问\n\n对于复杂任务，分步骤提问效果更好：\n\n```\n第一步：你：我想创建一个待办事项应用，先帮我设计数据结构\n第二步：你：现在帮我实现添加待办事项的功能\n第三步：你：添加删除和编辑功能\n第四步：你：最后添加本地存储功能\n```\n\n### 4. 请求多个方案\n\n让 AI 提供不同的实现方案，然后选择最适合的：\n\n```\n你：实现一个缓存系统，给我三种不同的方案\n\nAI：好的，我提供三种方案：\n1. 使用 Map 的简单内存缓存\n2. 使用 LRU 算法的高级缓存\n3. 使用 localStorage 的持久化缓存\n```\n\n### 5. 要求解释\n\n不仅要代码，还要理解原理：\n\n```\n你：这段代码是如何工作的？能详细解释一下吗？\n\nAI：当然，让我逐行解释...\n```\n\n## 最佳实践\n\n### ✅ 好的提问方式\n\n**具体明确**\n```\n❌ \"帮我写个函数\"\n✅ \"写一个 JavaScript 函数，接收数组和目标值，返回数组中两个数的索引，使它们的和等于目标值\"\n```\n\n**提供示例**\n```\n✅ \"创建一个函数验证邮箱，例如：\n   validateEmail('test@example.com') // true\n   validateEmail('invalid-email') // false\"\n```\n\n**说明约束条件**\n```\n✅ \"实现一个排序函数，要求：\n   - 使用快速排序算法\n   - 支持自定义比较函数\n   - 时间复杂度 O(n log n)\"\n```\n\n### ❌ 避免的提问方式\n\n**过于模糊**\n```\n❌ \"代码不工作\"\n✅ \"运行时出现 TypeError: Cannot read property 'length' of undefined\"\n```\n\n**一次问太多**\n```\n❌ \"帮我创建整个电商网站，包括前端、后端、数据库、支付系统...\"\n✅ 分步骤，先从一个功能模块开始\n```\n\n**缺少上下文**\n```\n❌ \"这个变量是什么？\"（没有选中代码）\n✅ 选中代码后问：\"这个变量的作用是什么？\"\n```\n\n## 高级功能\n\n### 代码审查\n\n请求 AI 审查你的代码：\n\n```\n你：请审查这段代码，指出潜在问题和改进建议\n[选中代码]\n\nAI：我发现以下几个问题：\n1. 缺少错误处理\n2. 变量命名不够清晰\n3. 可以使用更高效的算法\n...\n```\n\n### 生成测试\n\n让 AI 帮你编写测试用例：\n\n```\n你：为这个函数生成单元测试\n[选中函数]\n\nAI：我会为这个函数创建完整的测试套件...\n```\n\n### 文档生成\n\n自动生成代码文档：\n\n```\n你：为这个类生成 JSDoc 注释\n[选中类]\n\nAI：我会添加详细的 JSDoc 注释...\n```\n\n## 实际案例\n\n### 案例 1：实现 API 调用\n\n```\n你：帮我实现一个函数，从 REST API 获取用户数据，包含错误处理和重试逻辑\n\nAI：好的，我会创建一个健壮的 API 调用函数：\n\nasync function fetchUserData(userId, maxRetries = 3) {\n  let lastError;\n  \n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      const response = await fetch(`/api/users/${userId}`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      return data;\n    } catch (error) {\n      lastError = error;\n      console.warn(`Attempt ${attempt + 1} failed:`, error.message);\n      \n      // 等待后重试\n      if (attempt < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n      }\n    }\n  }\n  \n  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);\n}\n\n这个函数包含：\n- 自动重试机制（最多 3 次）\n- 指数退避策略\n- 完整的错误处理\n- HTTP 状态码检查\n```\n\n### 案例 2：性能优化\n\n```\n你：这个函数处理大数组时很慢，能优化吗？\n[选中函数]\n\nAI：我看到问题了。当前实现的时间复杂度是 O(n²)。我们可以使用 Map 优化到 O(n)：\n\n// 原始代码（慢）\nfunction findDuplicates(arr) {\n  const duplicates = [];\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {\n        duplicates.push(arr[i]);\n      }\n    }\n  }\n  return duplicates;\n}\n\n// 优化后的代码（快）\nfunction findDuplicates(arr) {\n  const seen = new Map();\n  const duplicates = new Set();\n  \n  for (const item of arr) {\n    if (seen.has(item)) {\n      duplicates.add(item);\n    } else {\n      seen.set(item, true);\n    }\n  }\n  \n  return Array.from(duplicates);\n}\n\n优化说明：\n- 使用 Map 记录已见元素，O(1) 查找\n- 使用 Set 自动去重\n- 单次遍历完成，O(n) 时间复杂度\n```\n\n## 常见问题\n\n### Q: 对话历史会保存吗？\n\n**A:** 是的，对话历史会保存在当前工作区中。你可以随时回顾之前的对话，或者清除历史记录。\n\n### Q: AI 能访问我的所有文件吗？\n\n**A:** AI 只能访问你明确引用或选中的代码。它不会自动读取整个项目，保护你的隐私。\n\n### Q: 如何获得更好的回答？\n\n**A:** 提供清晰的问题描述、相关的代码上下文、具体的需求和约束条件。问题越具体，答案越准确。\n\n### Q: 可以用中文对话吗？\n\n**A:** 完全可以！Claude Code 支持多种语言，包括简体中文。你可以用最舒适的语言与 AI 交流。\n\n## 下一步\n\n掌握对话式编程后，你可以继续学习：\n\n- [文件操作](/02-basics/file-operations) - 使用 Claude Code 管理项目文件\n- [代码示例](/02-basics/code-examples) - 查看更多实际编程案例\n\n## 小结\n\n对话式编程是 Claude Code 的强大功能，它改变了我们与代码交互的方式。通过清晰的沟通、提供足够的上下文、分步骤解决问题，你可以充分发挥 AI 助手的潜力。记住，AI 是你的编程伙伴，善用它可以大大提升你的开发效率和代码质量。\n",
    "chapterId": "02-basics",
    "tags": [
      "对话",
      "Chat",
      "协作编程",
      "最佳实践"
    ],
    "level": "beginner"
  },
  {
    "id": "02-basics-code-completion",
    "title": "代码补全功能",
    "content": "\n# 代码补全功能\n\nClaude Code 的代码补全功能是一个强大的 AI 助手，能够根据你的代码上下文智能地提供代码建议。与传统的代码补全工具不同，Claude Code 不仅能补全单个词或函数名，还能理解你的编程意图，生成完整的代码块、函数甚至整个类。\n\n## 什么是智能代码补全？\n\n智能代码补全是 Claude Code 的核心功能之一。当你在编辑器中输入代码时，AI 会实时分析你的代码上下文、项目结构和编程模式，然后提供最相关的代码建议。这些建议会以灰色文本的形式出现在光标位置，你可以选择接受或忽略。\n\n### 主要特点\n\n- **上下文感知**：理解当前文件、项目结构和编程语言\n- **多行补全**：不仅补全单行，还能生成完整的代码块\n- **智能推理**：根据函数名、注释和变量名推断你的意图\n- **实时响应**：在你输入时即时提供建议，无需等待\n\n## 如何使用代码补全\n\n### 基础使用流程\n\n1. **开始编写代码**：在编辑器中正常输入代码\n2. **等待建议**：AI 会在几毫秒内显示灰色的补全建议\n3. **接受建议**：按 `Tab` 键接受整个建议\n4. **部分接受**：按 `Ctrl + →`（Windows/Linux）或 `Cmd + →`（macOS）接受建议的下一个词\n5. **忽略建议**：继续输入或按 `Esc` 键忽略当前建议\n\n### 实用快捷键\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Tab` | 接受完整建议 | 接受 AI 提供的全部代码 |\n| `Ctrl/Cmd + →` | 接受下一个词 | 逐词接受建议，更精确控制 |\n| `Esc` | 取消建议 | 关闭当前的补全建议 |\n| `Alt + [` | 查看上一个建议 | 在多个建议间切换 |\n| `Alt + ]` | 查看下一个建议 | 在多个建议间切换 |\n\n## 代码示例\n\n### 示例 1：函数补全\n\n当你开始编写一个函数时，Claude Code 会根据函数名推断其功能：\n\n```javascript\n// 你输入：\nfunction calculateTotalPrice\n\n// AI 建议：\nfunction calculateTotalPrice(items, taxRate) {\n  const subtotal = items.reduce((sum, item) => sum + item.price, 0);\n  const tax = subtotal * taxRate;\n  return subtotal + tax;\n}\n```\n\n### 示例 2：类方法补全\n\n在类中添加方法时，AI 会考虑类的上下文：\n\n```python\nclass UserManager:\n    def __init__(self):\n        self.users = []\n    \n    # 你输入：\n    def add_user\n    \n    # AI 建议：\n    def add_user(self, name, email):\n        user = {\n            'id': len(self.users) + 1,\n            'name': name,\n            'email': email\n        }\n        self.users.append(user)\n        return user\n```\n\n### 示例 3：注释驱动开发\n\n通过编写注释，引导 AI 生成代码：\n\n```typescript\n// 你输入注释：\n// 创建一个函数，验证邮箱地址格式是否正确\n\n// AI 建议完整实现：\nfunction validateEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n```\n\n## 使用技巧\n\n### 1. 编写清晰的函数名\n\n函数名越清晰，AI 的建议就越准确。使用描述性的命名：\n\n```javascript\n// ✅ 好的命名\nfunction getUsersByAgeRange(minAge, maxAge) { ... }\n\n// ❌ 不好的命名\nfunction getData(a, b) { ... }\n```\n\n### 2. 利用注释引导\n\n在复杂逻辑前添加注释，帮助 AI 理解你的意图：\n\n```python\n# 计算斐波那契数列的第 n 项，使用动态规划优化\ndef fibonacci(n):\n    # AI 会根据注释生成优化的实现\n```\n\n### 3. 保持代码上下文\n\n确保相关代码在同一文件中，AI 能更好地理解项目结构：\n\n```javascript\n// 定义接口\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// AI 会根据接口定义生成类型安全的函数\nfunction createUser\n```\n\n### 4. 分步骤编写\n\n对于复杂功能，分步骤编写可以获得更好的建议：\n\n```javascript\n// 第一步：定义函数签名\nasync function fetchUserData(userId) {\n  \n// 第二步：AI 会建议完整的实现\n  const response = await fetch(`/api/users/${userId}`);\n  const data = await response.json();\n  return data;\n}\n```\n\n## 常见问题\n\n### Q: 代码补全没有出现怎么办？\n\n**A:** 检查以下几点：\n- 确保 Claude Code 已正确安装并激活\n- 检查网络连接是否正常\n- 尝试重启编辑器\n- 查看设置中代码补全功能是否已启用\n\n### Q: 补全建议不准确怎么办？\n\n**A:** 可以尝试：\n- 添加更多上下文代码\n- 使用注释说明你的意图\n- 改进变量和函数的命名\n- 忽略当前建议，继续输入以获得新建议\n\n### Q: 如何临时禁用代码补全？\n\n**A:** 按 `Ctrl/Cmd + Shift + P` 打开命令面板，搜索 \"Claude Code: Toggle Inline Suggestions\" 来切换补全功能。\n\n## 下一步\n\n现在你已经掌握了代码补全的基础知识，接下来可以学习：\n\n- [对话式编程](/02-basics/chat) - 通过对话与 AI 协作编程\n- [文件操作](/02-basics/file-operations) - 使用 Claude Code 管理项目文件\n\n## 小结\n\n代码补全是 Claude Code 最常用的功能之一。通过合理使用快捷键、编写清晰的代码和注释，你可以大大提升编程效率。记住，AI 是你的助手，而不是替代品——始终要理解和审查 AI 生成的代码。\n",
    "chapterId": "02-basics",
    "tags": [
      "代码补全",
      "快捷键",
      "基础功能"
    ],
    "level": "beginner"
  },
  {
    "id": "02-basics-code-examples",
    "title": "代码示例集合",
    "content": "\n# 代码示例集合\n\n本章节提供了多种编程语言的实用代码示例，展示如何使用 Claude Code 来编写高质量的代码。这些示例涵盖了常见的编程任务和最佳实践。\n\n## JavaScript/TypeScript 示例\n\n### 示例 1：异步数据获取和错误处理\n\n```javascript\n// 使用 async/await 的现代异步编程方式\nasync function fetchUserData(userId) {\n  try {\n    // 验证输入\n    if (!userId || typeof userId !== 'string') {\n      throw new Error('Invalid userId');\n    }\n\n    // 获取用户数据\n    const response = await fetch(`/api/users/${userId}`);\n    \n    // 检查响应状态\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const data = await response.json();\n    \n    // 验证返回数据\n    if (!data || !data.id) {\n      throw new Error('Invalid user data');\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Failed to fetch user data:', error);\n    // 返回默认值或重新抛出错误\n    throw error;\n  }\n}\n\n// 使用示例\nasync function main() {\n  try {\n    const user = await fetchUserData('user123');\n    console.log('User:', user);\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\nmain();\n```\n\n### 示例 2：React 组件 - 用户列表\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  avatar?: string;\n}\n\ninterface UserListProps {\n  onUserSelect?: (user: User) => void;\n}\n\nexport const UserList: React.FC<UserListProps> = ({ onUserSelect }) => {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [searchTerm, setSearchTerm] = useState('');\n\n  // 获取用户列表\n  useEffect(() => {\n    const fetchUsers = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch('/api/users');\n        if (!response.ok) throw new Error('Failed to fetch users');\n        const data = await response.json();\n        setUsers(data);\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Unknown error');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUsers();\n  }, []);\n\n  // 过滤用户\n  const filteredUsers = users.filter(user =>\n    user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    user.email.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  if (loading) return <div className=\"p-4\">加载中...</div>;\n  if (error) return <div className=\"p-4 text-red-600\">错误: {error}</div>;\n\n  return (\n    <div className=\"p-4\">\n      <h2 className=\"text-2xl font-bold mb-4\">用户列表</h2>\n      \n      {/* 搜索框 */}\n      <input\n        type=\"text\"\n        placeholder=\"搜索用户...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        className=\"w-full px-4 py-2 border rounded mb-4\"\n      />\n\n      {/* 用户列表 */}\n      <div className=\"space-y-2\">\n        {filteredUsers.length > 0 ? (\n          filteredUsers.map(user => (\n            <div\n              key={user.id}\n              onClick={() => onUserSelect?.(user)}\n              className=\"p-3 border rounded hover:bg-gray-100 cursor-pointer\"\n            >\n              <div className=\"font-semibold\">{user.name}</div>\n              <div className=\"text-sm text-gray-600\">{user.email}</div>\n            </div>\n          ))\n        ) : (\n          <div className=\"text-gray-500\">未找到匹配的用户</div>\n        )}\n      </div>\n    </div>\n  );\n};\n```\n\n## Python 示例\n\n### 示例 1：数据处理和分析\n\n```python\nimport json\nfrom typing import List, Dict, Any\nfrom datetime import datetime\n\nclass DataProcessor:\n    \"\"\"数据处理类，用于处理和分析数据\"\"\"\n    \n    def __init__(self, data: List[Dict[str, Any]]):\n        \"\"\"\n        初始化数据处理器\n        \n        Args:\n            data: 数据列表\n        \"\"\"\n        self.data = data\n        self.processed_data = []\n    \n    def filter_by_date_range(self, start_date: str, end_date: str) -> List[Dict]:\n        \"\"\"\n        按日期范围过滤数据\n        \n        Args:\n            start_date: 开始日期 (YYYY-MM-DD)\n            end_date: 结束日期 (YYYY-MM-DD)\n        \n        Returns:\n            过滤后的数据列表\n        \"\"\"\n        try:\n            start = datetime.strptime(start_date, '%Y-%m-%d')\n            end = datetime.strptime(end_date, '%Y-%m-%d')\n            \n            filtered = [\n                item for item in self.data\n                if start <= datetime.strptime(item['date'], '%Y-%m-%d') <= end\n            ]\n            return filtered\n        except ValueError as e:\n            print(f\"日期格式错误: {e}\")\n            return []\n    \n    def aggregate_by_category(self, category_key: str) -> Dict[str, float]:\n        \"\"\"\n        按类别聚合数据\n        \n        Args:\n            category_key: 类别键名\n        \n        Returns:\n            按类别聚合的结果\n        \"\"\"\n        aggregated = {}\n        for item in self.data:\n            category = item.get(category_key, 'Unknown')\n            value = item.get('value', 0)\n            aggregated[category] = aggregated.get(category, 0) + value\n        return aggregated\n    \n    def calculate_statistics(self, value_key: str = 'value') -> Dict[str, float]:\n        \"\"\"\n        计算统计信息\n        \n        Args:\n            value_key: 值的键名\n   ",
    "chapterId": "02-basics",
    "tags": [
      "代码示例",
      "多语言",
      "实践",
      "最佳实践"
    ],
    "level": "beginner"
  },
  {
    "id": "02-basics-file-operations",
    "title": "文件操作和项目管理",
    "content": "\n# 文件操作和项目管理\n\nClaude Code 提供了强大的文件管理功能，让你能够高效地组织和管理项目文件。本章节将介绍如何使用 Claude Code 的文件操作功能来提高工作效率。\n\n## 文件浏览器基础\n\n### 打开文件浏览器\n\nClaude Code 的文件浏览器位于左侧活动栏。你可以：\n\n1. **点击文件图标**打开文件浏览器\n2. **使用快捷键** `Ctrl+Shift+E`（Windows/Linux）或 `Cmd+Shift+E`（macOS）\n3. **从菜单**选择\"查看\" > \"资源管理器\"\n\n### 文件浏览器的主要功能\n\n- **文件树视图**：显示项目的完整目录结构\n- **快速搜索**：在文件浏览器中搜索文件\n- **上下文菜单**：右键点击文件或文件夹获取操作选项\n- **拖放操作**：拖放文件进行移动或复制\n- **文件预览**：点击文件快速预览内容\n\n## 创建和删除文件\n\n### 创建新文件\n\n有多种方式创建新文件：\n\n**方式 1：通过文件浏览器**\n1. 在文件浏览器中右键点击文件夹\n2. 选择\"新建文件\"\n3. 输入文件名并按 Enter\n\n**方式 2：使用快捷键**\n- 按 `Ctrl+N`（Windows/Linux）或 `Cmd+N`（macOS）创建新文件\n- 输入文件名和路径\n\n**方式 3：通过命令面板**\n- 按 `Ctrl+Shift+P`（Windows/Linux）或 `Cmd+Shift+P`（macOS）\n- 搜索\"新建文件\"\n- 输入文件名\n\n### 创建新文件夹\n\n1. 在文件浏览器中右键点击\n2. 选择\"新建文件夹\"\n3. 输入文件夹名称\n\n### 删除文件和文件夹\n\n1. 在文件浏览器中右键点击要删除的项目\n2. 选择\"删除\"\n3. 确认删除操作\n\n**注意**：删除操作会将文件移到回收站，你可以恢复。\n\n## 文件重命名和移动\n\n### 重命名文件\n\n**方式 1：通过文件浏览器**\n1. 右键点击文件\n2. 选择\"重命名\"\n3. 输入新名称\n\n**方式 2：快速重命名**\n- 选中文件后按 `F2` 键\n- 输入新名称\n\n### 移动文件\n\n**方式 1：拖放操作**\n- 在文件浏览器中拖动文件到目标文件夹\n\n**方式 2：剪切和粘贴**\n1. 右键点击文件，选择\"剪切\"（或按 `Ctrl+X`）\n2. 导航到目标文件夹\n3. 右键点击，选择\"粘贴\"（或按 `Ctrl+V`）\n\n### 复制文件\n\n1. 右键点击文件，选择\"复制\"（或按 `Ctrl+C`）\n2. 导航到目标位置\n3. 右键点击，选择\"粘贴\"（或按 `Ctrl+V`）\n\n## 项目结构最佳实践\n\n### 推荐的项目结构\n\n对于一个典型的 Web 项目，推荐的目录结构如下：\n\n```\nmy-project/\n├── src/                    # 源代码目录\n│   ├── components/         # React 组件\n│   ├── pages/             # 页面组件\n│   ├── utils/             # 工具函数\n│   ├── styles/            # 样式文件\n│   ├── hooks/             # 自定义 hooks\n│   └── App.tsx            # 主应用组件\n├── public/                # 静态资源\n│   ├── images/\n│   ├── fonts/\n│   └── index.html\n├── tests/                 # 测试文件\n│   ├── unit/\n│   └── integration/\n├── docs/                  # 文档\n├── .env                   # 环境变量\n├── .gitignore            # Git 忽略文件\n├── package.json          # 项目配置\n├── tsconfig.json         # TypeScript 配置\n└── README.md             # 项目说明\n```\n\n### 命名规范\n\n**文件夹命名**\n- 使用小写字母和连字符：`my-folder`\n- 避免空格和特殊字符\n- 使用复数形式表示集合：`components`、`utils`\n\n**文件命名**\n- React 组件：PascalCase（`UserProfile.tsx`）\n- 工具函数：camelCase（`formatDate.ts`）\n- 样式文件：kebab-case（`user-profile.css`）\n- 测试文件：`*.test.ts` 或 `*.spec.ts`\n\n## 使用 Claude Code 管理文件\n\n### 让 AI 帮助组织项目\n\n你可以在 Chat 中请求 AI 帮助：\n\n```\n你：我的项目结构很混乱，能帮我重新组织一下吗？\n[选中项目文件夹]\n\nAI：我看到你的项目结构。我建议按照以下方式重新组织...\n```\n\n### 批量操作\n\n使用 Claude Code 的多选功能进行批量操作：\n\n1. 按住 `Ctrl`（Windows/Linux）或 `Cmd`（macOS）点击多个文件\n2. 右键点击选中的文件\n3. 选择操作（删除、移动、复制等）\n\n### 搜索和替换文件内容\n\n**全局搜索**\n- 按 `Ctrl+Shift+F`（Windows/Linux）或 `Cmd+Shift+F`（macOS）\n- 输入搜索词\n- 查看所有匹配的文件和位置\n\n**全局替换**\n- 在搜索框中输入搜索词\n- 点击\"替换\"按钮\n- 输入替换内容\n- 选择\"全部替换\"\n\n## 工作区和多文件夹\n\n### 打开多个文件夹\n\nClaude Code 支持在同一工作区中打开多个文件夹：\n\n1. 点击\"文件\" > \"将文件夹添加到工作区\"\n2. 选择要添加的文件夹\n3. 文件夹会显示在文件浏览器中\n\n### 工作区配置\n\n你可以保存工作区配置：\n\n1. 点击\"文件\" > \"将工作区另存为\"\n2. 输入工作区名称\n3. 下次打开时可以快速恢复相同的文件夹配置\n\n## 文件同步和备份\n\n### 自动保存\n\nClaude Code 支持自动保存功能：\n\n1. 打开设置（`Ctrl+,` 或 `Cmd+,`）\n2. 搜索\"Auto Save\"\n3. 选择自动保存模式：\n   - `off`：禁用自动保存\n   - `afterDelay`：延迟后自动保存（默认 1000ms）\n   - `onFocusChange`：切换窗口时自动保存\n   - `onWindowChange`：切换应用时自动保存\n\n### 版本控制集成\n\nClaude Code 与 Git 深度集成：\n\n1. 在文件浏览器中查看 Git 状态\n2. 使用 Source Control 面板管理版本\n3. 直接在编辑器中查看文件变更\n\n## 常见文件操作快捷键\n\n| 快捷键 | 功能 |\n|--------|------|\n| `Ctrl+N` / `Cmd+N` | 新建文件 |\n| `Ctrl+O` / `Cmd+O` | 打开文件 |\n| `Ctrl+S` / `Cmd+S` | 保存文件 |\n| `Ctrl+Shift+S` / `Cmd+Shift+S` | 另存为 |\n| `Ctrl+W` / `Cmd+W` | 关闭文件 |\n| `Ctrl+K Ctrl+W` / `Cmd+K Cmd+W` | 关闭所有文件 |\n| `Ctrl+Tab` / `Cmd+Tab` | 切换打开的文件 |\n| `Ctrl+Shift+E` / `Cmd+Shift+E` | 打开文件浏览器 |\n| `Ctrl+Shift+F` / `Cmd+Shift+F` | 全局搜索 |\n| `F2` | 重命名文件 |\n\n## 实用技巧\n\n### 1. 快速打开文件\n\n使用 `Ctrl+P`（Windows/Linux）或 `Cmd+P`（macOS）快速打开文件：\n\n- 输入文件名的一部分\n- 支持模糊匹配\n- 按 Enter 打开文件\n\n### 2. 最近打开的文件\n\n点击\"文件\" > \"最近打开\"查看最近打开的文件列表。\n\n### 3. 文件对比\n\n要比较两个文件的差异：\n\n1. 右键点击第一个文件，选择\"选择用于比较\"\n2. 右键点击第二个文件，选择\"与选定的文件进行比较\"\n3. 查看两个文件的差异\n\n### 4. 文件预览\n\n在文件浏览器中单击文件（不是双击）可以预览文件内容，而不打开编辑标签。\n\n## 常见问题\n\n### Q: 如何恢复已删除的文件？\n\n**A:** 删除的文件会进入回收站。你可以：\n1. 打开系统回收站\n2. 找到要恢复的文件\n3. 右键点击，选择\"还原\"\n\n### Q: 如何在多个文件中进行查找和替换？\n\n**A:** 使用全局搜索和替换功能：\n1. 按 `Ctrl+Shift+F`（Windows/Linux）或 `Cmd+Shift+F`（macOS）\n2. 输入搜索词\n3. 点击\"替换\"按钮\n4. 输入替换内容\n5. 选择\"全部替换\"\n\n### Q: 如何快速导航到特定文件？\n\n**A:** 使用快速打开功能：\n1. 按 `Ctrl+P`（Windows/Linux）或 `Cmd+P`（macOS）\n2. 输入文件名\n3. 按 Enter 打开\n\n## 下一步\n\n现在你已经掌握了文件操作的基础知识，可以继续学习：\n\n- [代码示例](/02-basics/code-examples) - 查看更多实际编程案例\n- [进阶功能](/03-advanced/specs) - 学习 Specs 工作流程\n\n## 小结\n\n高效的文件管理是提高开发效率的基础。通过掌握 Claude Code 的文件操作功能，你可以：\n\n- ✅ 快速创建、删除和重命名文件\n- ✅ 组织清晰的项目结构\n- ✅ 使用快捷键加速工作流程\n- ✅ 利用 AI 帮助优化项目组织\n- ✅ 与版本控制系统无缝集成\n\n记住，一个组织良好的项目结构不仅能提高你的工作效率，还能让团队成员更容易理解和维护代码。\n",
    "chapterId": "02-basics",
    "tags": [
      "文件操作",
      "项目管理",
      "工作流程"
    ],
    "level": "beginner"
  },
  {
    "id": "02-basics-practice",
    "title": "实践练习",
    "content": "\n# 实践练习\n\n在这一章中，你将通过交互式练习和测验来巩固之前学到的知识。\n\n## 练习 1：编写你的第一个函数\n\n让我们从一个简单的练习开始。你需要编写一个函数，接收一个名字作为参数，并返回一个问候语。\n\n```javascript\n// 练习 1：编写问候函数\n// 要求：编写一个函数，接收一个名字参数，返回格式为 'Hello, [name]!' 的问候语\n\nfunction greet(name) {\n  // 在这里编写你的代码\n  return `Hello, ${name}!`;\n}\n\n// 测试\nconsole.log(greet(\"World\"));  // 输出: Hello, World!\nconsole.log(greet(\"Alice\"));  // 输出: Hello, Alice!\n```\n\n## 练习 2：数组操作\n\n现在让我们练习数组操作。你需要编写一个函数，计算数组中所有数字的总和。\n\n```javascript\n// 练习 2：计算数组总和\n// 要求：编写一个函数，接收一个数字数组，返回所有数字的总和\n\nfunction sumArray(arr) {\n  // 方法 1：使用 reduce\n  return arr.reduce((sum, num) => sum + num, 0);\n  \n  // 方法 2：使用 for 循环\n  // let sum = 0;\n  // for (let num of arr) {\n  //   sum += num;\n  // }\n  // return sum;\n}\n\n// 测试\nconsole.log(sumArray([1, 2, 3, 4, 5]));  // 输出: 15\nconsole.log(sumArray([10, 20, 30]));     // 输出: 60\n```\n\n## 知识检测测验\n\n现在让我们通过一个测验来检测你对 Claude Code 基础知识的理解。\n\n## 知识检测\n\n### 问题 1：Claude Code 的主要功能是什么？\n- A. 只能编写 HTML\n- B. AI 辅助编程工具，提供代码补全和对话式编程 ✅\n- C. 一个版本控制系统\n- D. 一个数据库管理工具\n\n**答案**：B - Claude Code 是一个 AI 辅助编程工具，主要功能包括智能代码补全、对话式编程和代码理解。\n\n### 问题 2：以下哪个是 Claude Code 的优势？\n- A. 只支持 Python\n- B. 需要手动编写所有代码\n- C. 可以快速编写代码并理解复杂的代码库 ✅\n- D. 不支持调试功能\n\n**答案**：C - Claude Code 的优势包括快速编写代码、理解复杂代码库、调试和优化代码等功能。\n\n### 问题 3：对话式编程是什么意思？\n- A. 与其他程序员聊天\n- B. 通过自然语言与 AI 助手对话来编程 ✅\n- C. 在代码中添加注释\n- D. 使用特殊的编程语言\n\n**答案**：B - 对话式编程是指通过自然语言与 AI 助手对话，让 AI 帮助你编写和理解代码。\n\n### 问题 4：Claude Code 支持哪些编程语言？\n- A. 只支持 JavaScript\n- B. 只支持 Python\n- C. 支持多种编程语言，包括 JavaScript、Python、Java 等 ✅\n- D. 不支持任何编程语言\n\n**答案**：C - Claude Code 支持多种编程语言，包括 JavaScript、Python、TypeScript、Java、Go 等。\n\n## 总结\n\n通过这些练习和测验，你已经：\n\n1. ✅ 学会了如何编写基本的 JavaScript 函数\n2. ✅ 练习了数组操作\n3. ✅ 检测了你对 Claude Code 基础知识的理解\n\n继续学习更多高级功能吧！\n",
    "chapterId": "02-basics",
    "tags": [
      "练习",
      "测验",
      "交互式"
    ],
    "level": "beginner"
  },
  {
    "id": "03-advanced-hooks",
    "title": "Agent Hooks 自动化工作流",
    "content": "\n# Agent Hooks 自动化工作流\n\nAgent Hooks 是 Claude Code 的一个强大功能，它允许你创建自动化的工作流程，在特定事件发生时自动执行 AI 任务。通过 Hooks，你可以消除重复性的工作，提高开发效率。\n\n## 什么是 Agent Hooks？\n\nAgent Hooks 是事件驱动的自动化规则。当特定事件发生时（例如保存文件、提交代码、更新文档），Hook 会自动触发 Claude Code 执行预定义的任务。\n\n### 核心概念\n\n- **事件**：触发 Hook 的条件（文件保存、代码提交等）\n- **条件**：可选的额外条件（文件类型、路径匹配等）\n- **操作**：Hook 触发时执行的任务（运行测试、生成文档等）\n\n## 常见 Hook 场景\n\n### 1. 自动测试\n\n当你保存代码文件时，自动运行相关的测试：\n\n```yaml\nname: Auto Test on Save\ntrigger: file_saved\ncondition:\n  path: \"src/**/*.ts\"\naction:\n  type: run_command\n  command: \"npm test -- --testPathPattern=src\"\n```\n\n### 2. 代码审查\n\n当你提交代码时，自动进行代码审查：\n\n```yaml\nname: Auto Code Review\ntrigger: before_commit\naction:\n  type: chat\n  prompt: \"请审查这些代码变更，指出潜在问题和改进建议\"\n```\n\n### 3. 文档更新\n\n当你修改 API 时，自动更新相关文档：\n\n```yaml\nname: Update API Docs\ntrigger: file_saved\ncondition:\n  path: \"src/api/**/*.ts\"\naction:\n  type: chat\n  prompt: \"为这个 API 文件生成或更新 JSDoc 注释\"\n```\n\n### 4. 翻译同步\n\n当你更新英文文档时，自动更新其他语言版本：\n\n```yaml\nname: Sync Translations\ntrigger: file_saved\ncondition:\n  path: \"docs/en/**/*.md\"\naction:\n  type: chat\n  prompt: \"将这个文档翻译成中文、日文和西班牙文\"\n```\n\n## 创建 Agent Hooks\n\n### 方法 1：通过 UI\n\n1. 打开 Claude Code\n2. 打开命令面板（`Ctrl+Shift+P` 或 `Cmd+Shift+P`）\n3. 搜索\"Open Kiro Hook UI\"\n4. 点击\"创建新 Hook\"\n5. 填写 Hook 配置\n\n### 方法 2：编辑配置文件\n\n在 `.kiro/hooks/` 目录中创建 YAML 文件：\n\n```yaml\n# .kiro/hooks/auto-test.yaml\nname: \"自动运行测试\"\ndescription: \"当保存 TypeScript 文件时自动运行测试\"\nenabled: true\n\ntrigger:\n  type: \"file_saved\"\n  \ncondition:\n  path: \"src/**/*.ts\"\n  exclude: \"src/**/*.test.ts\"\n\naction:\n  type: \"run_command\"\n  command: \"npm test -- --testPathPattern=${file_name}\"\n  \nnotification:\n  on_success: \"✅ 测试通过\"\n  on_failure: \"❌ 测试失败\"\n```\n\n## Hook 配置详解\n\n### 触发器类型\n\n| 触发器 | 说明 | 示例 |\n|--------|------|------|\n| `file_saved` | 文件保存时 | 自动格式化、运行测试 |\n| `file_created` | 文件创建时 | 生成模板、添加许可证 |\n| `file_deleted` | 文件删除时 | 更新导入、清理引用 |\n| `before_commit` | 提交前 | 代码审查、运行检查 |\n| `after_commit` | 提交后 | 更新文档、发送通知 |\n| `manual` | 手动触发 | 通过命令面板触发 |\n\n### 条件配置\n\n```yaml\ncondition:\n  # 路径匹配（支持 glob 模式）\n  path: \"src/**/*.ts\"\n  \n  # 排除路径\n  exclude: \"src/**/*.test.ts\"\n  \n  # 文件大小限制（字节）\n  maxSize: 10000\n  \n  # 自定义条件\n  custom: \"file.name.includes('Component')\"\n```\n\n### 操作类型\n\n#### 1. 运行命令\n\n```yaml\naction:\n  type: \"run_command\"\n  command: \"npm test\"\n  cwd: \".\"  # 工作目录\n  timeout: 30000  # 超时时间（毫秒）\n```\n\n#### 2. Chat 对话\n\n```yaml\naction:\n  type: \"chat\"\n  prompt: \"请审查这个文件并提出改进建议\"\n  context: \"file\"  # 包含文件内容作为上下文\n```\n\n#### 3. 文件操作\n\n```yaml\naction:\n  type: \"file_operation\"\n  operation: \"create\"  # create, update, delete\n  path: \"docs/${file_name}.md\"\n  content: \"# ${file_name}\\n\\n自动生成的文档\"\n```\n\n#### 4. 格式化\n\n```yaml\naction:\n  type: \"format\"\n  formatter: \"prettier\"  # prettier, eslint, black 等\n  options:\n    semi: true\n    singleQuote: true\n```\n\n## 实际 Hook 示例\n\n### 示例 1：自动生成测试\n\n```yaml\n# .kiro/hooks/generate-tests.yaml\nname: \"自动生成测试文件\"\ndescription: \"为新创建的 TypeScript 文件自动生成测试框架\"\nenabled: true\n\ntrigger:\n  type: \"file_created\"\n\ncondition:\n  path: \"src/**/*.ts\"\n  exclude: \"src/**/*.test.ts\"\n\naction:\n  type: \"chat\"\n  prompt: |\n    为这个文件生成完整的单元测试。\n    \n    要求：\n    1. 使用 Jest 框架\n    2. 覆盖所有导出的函数\n    3. 包含边界情况测试\n    4. 添加详细的测试描述\n    \n    将测试文件保存为 ${file_name}.test.ts\n  context: \"file\"\n\nnotification:\n  on_success: \"✅ 测试文件已生成\"\n  on_failure: \"❌ 生成测试文件失败\"\n```\n\n### 示例 2：代码审查\n\n```yaml\n# .kiro/hooks/code-review.yaml\nname: \"自动代码审查\"\ndescription: \"在提交前自动审查代码变更\"\nenabled: true\n\ntrigger:\n  type: \"before_commit\"\n\naction:\n  type: \"chat\"\n  prompt: |\n    请审查这些代码变更。检查以下方面：\n    \n    1. 代码质量和可读性\n    2. 潜在的 bug 和性能问题\n    3. 安全性问题\n    4. 是否遵循项目的编码规范\n    5. 是否需要添加测试或文档\n    \n    如果发现问题，请列出具体的改进建议。\n  context: \"git_diff\"\n\nnotification:\n  on_success: \"✅ 代码审查完成\"\n  on_failure: \"❌ 代码审查失败\"\n```\n\n### 示例 3：文档同步\n\n```yaml\n# .kiro/hooks/sync-docs.yaml\nname: \"同步文档翻译\"\ndescription: \"当英文文档更新时，自动更新其他语言版本\"\nenabled: true\n\ntrigger:\n  type: \"file_saved\"\n\ncondition:\n  path: \"docs/en/**/*.md\"\n\naction:\n  type: \"chat\"\n  prompt: |\n    这个英文文档已更新。请：\n    \n    1. 将内容翻译成中文\n    2. 将内容翻译成日文\n    3. 将内容翻译成西班牙文\n    \n    为每种语言创建对应的文件：\n    - docs/zh/${file_name}\n    - docs/ja/${file_name}\n    - docs/es/${file_name}\n    \n    确保翻译准确且符合各语言的表达习惯。\n  context: \"file\"\n\nnotification:\n  on_success: \"✅ 文档已翻译\"\n  on_failure: \"❌ 文档翻译失败\"\n```\n\n### 示例 4：自动格式化和 Lint\n\n```yaml\n# .kiro/hooks/format-on-save.yaml\nname: \"保存时自动格式化\"\ndescription: \"保存文件时自动格式化和运行 Lint 检查\"\nenabled: true\n\ntrigger:\n  type: \"file_saved\"\n\ncondition:\n  path: \"src/**/*.{ts,tsx,js,jsx}\"\n\nactions:\n  - type: \"format\"\n    formatter: \"prettier\"\n    options:\n      semi: true\n      singleQuote: true\n      trailingComma: \"es5\"\n  \n  - type: \"run_command\"\n    command: \"npm run lint -- --fix ${file_path}\"\n\nnotification:\n  on_success: \"✅ 文件已格式化\"\n  on_failure: \"❌ 格式化失败\"\n```\n\n## Hook 管理\n\n### 查看所有 Hooks\n\n1. 打开命令面板\n2. 搜索\"Kiro: List Hooks\"\n3. 查看所有已配置的 Hooks\n\n### 启用/禁用 Hooks\n\n在 Hook 配置中修改 `enabled` 字段：\n\n```yaml\nenabled: false  # 禁用此 Hook\n```\n\n或通过命令面板：\n\n1. 搜索\"Kiro: Toggle Hook\"\n2. 选择要切换的 Hook\n\n### 手动触发 Hook\n\n对于 `manual` 类型的 Hook，可以通过命令面板手动触发：\n\n1. 打开命令面板\n2. 搜索\"Kiro: Run Hook\"\n3. 选择要运行的 Hook\n\n## Hook 最佳实践\n\n### 1. 明确的目的\n\n每个 Hook 应该有明确的目的，不要",
    "chapterId": "03-advanced",
    "tags": [
      "Hooks",
      "自动化",
      "工作流程",
      "进阶功能"
    ],
    "level": "advanced"
  },
  {
    "id": "03-advanced-mcp",
    "title": "MCP 集成指南",
    "content": "\n# MCP 集成指南\n\nModel Context Protocol（MCP）是一个开放标准，允许 Claude Code 与外部工具和服务集成。通过 MCP，你可以扩展 Claude Code 的功能，连接到数据库、API、文档系统等。\n\n## 什么是 MCP？\n\nMCP 是一个协议，定义了 Claude Code 与外部工具之间的通信方式。它允许：\n\n- **数据访问**：访问数据库、文件系统、API\n- **工具集成**：集成开发工具、构建系统、部署工具\n- **知识库**：连接文档、代码库、参考资料\n- **自定义功能**：创建特定于项目的工具和功能\n\n## MCP 的优势\n\n### 1. 扩展功能\n\n通过 MCP，你可以为 Claude Code 添加自定义功能。\n\n### 2. 数据访问\n\nAI 可以访问你的数据库、API 和文件系统，提供更准确的建议。\n\n### 3. 工具集成\n\n集成你已经使用的开发工具，创建统一的工作流程。\n\n### 4. 知识增强\n\n连接你的文档和代码库，让 AI 更好地理解你的项目。\n\n## 配置 MCP\n\n### 配置文件位置\n\nMCP 配置文件有两个位置：\n\n1. **工作区级别**：`.kiro/settings/mcp.json`（项目特定）\n2. **用户级别**：`~/.kiro/settings/mcp.json`（全局）\n\n工作区级别的配置优先级更高。\n\n### 基本配置结构\n\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"uvx\",\n      \"args\": [\"package@version\"],\n      \"env\": {\n        \"KEY\": \"value\"\n      },\n      \"disabled\": false,\n      \"autoApprove\": [\"tool1\", \"tool2\"]\n    }\n  }\n}\n```\n\n## 常见 MCP 服务器\n\n### 1. AWS 文档服务器\n\n访问 AWS 官方文档：\n\n```json\n{\n  \"mcpServers\": {\n    \"aws-docs\": {\n      \"command\": \"uvx\",\n      \"args\": [\"awslabs.aws-documentation-mcp-server@latest\"],\n      \"env\": {\n        \"FASTMCP_LOG_LEVEL\": \"ERROR\"\n      },\n      \"disabled\": false,\n      \"autoApprove\": []\n    }\n  }\n}\n```\n\n**使用示例**：\n\n```\n你：@aws-docs 如何在 AWS Lambda 中使用环境变量？\n\nAI：根据 AWS 文档，你可以通过以下方式在 Lambda 中使用环境变量...\n```\n\n### 2. 文件系统服务器\n\n访问项目文件系统：\n\n```json\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-filesystem\"],\n      \"disabled\": false,\n      \"autoApprove\": [\"read_file\", \"list_directory\"]\n    }\n  }\n}\n```\n\n### 3. Git 服务器\n\n访问 Git 仓库信息：\n\n```json\n{\n  \"mcpServers\": {\n    \"git\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-git\"],\n      \"disabled\": false,\n      \"autoApprove\": [\"get_repository_status\", \"get_commit_history\"]\n    }\n  }\n}\n```\n\n### 4. 数据库服务器\n\n连接到数据库：\n\n```json\n{\n  \"mcpServers\": {\n    \"database\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-database\"],\n      \"env\": {\n        \"DATABASE_URL\": \"postgresql://user:password@localhost/dbname\"\n      },\n      \"disabled\": false,\n      \"autoApprove\": [\"query_database\"]\n    }\n  }\n}\n```\n\n## 创建自定义 MCP 服务器\n\n### 基本结构\n\n创建一个简单的 MCP 服务器：\n\n```python\n# mcp_server.py\nimport json\nfrom typing import Any\n\nclass MCPServer:\n    def __init__(self):\n        self.tools = {\n            \"get_project_info\": self.get_project_info,\n            \"analyze_code\": self.analyze_code,\n            \"generate_report\": self.generate_report,\n        }\n    \n    def get_project_info(self, project_id: str) -> dict:\n        \"\"\"获取项目信息\"\"\"\n        return {\n            \"id\": project_id,\n            \"name\": \"My Project\",\n            \"description\": \"Project description\",\n            \"technologies\": [\"React\", \"TypeScript\", \"Node.js\"]\n        }\n    \n    def analyze_code(self, file_path: str) -> dict:\n        \"\"\"分析代码文件\"\"\"\n        return {\n            \"file\": file_path,\n            \"lines\": 150,\n            \"complexity\": \"medium\",\n            \"issues\": []\n        }\n    \n    def generate_report(self, project_id: str) -> dict:\n        \"\"\"生成项目报告\"\"\"\n        return {\n            \"project_id\": project_id,\n            \"report\": \"Project analysis report\",\n            \"timestamp\": \"2025-11-16T10:00:00Z\"\n        }\n    \n    def handle_request(self, tool_name: str, params: dict) -> Any:\n        \"\"\"处理请求\"\"\"\n        if tool_name in self.tools:\n            return self.tools[tool_name](**params)\n        else:\n            raise ValueError(f\"Unknown tool: {tool_name}\")\n\n# 主程序\nif __name__ == \"__main__\":\n    server = MCPServer()\n    \n    # 示例调用\n    result = server.handle_request(\"get_project_info\", {\"project_id\": \"123\"})\n    print(json.dumps(result, indent=2))\n```\n\n### 注册自定义服务器\n\n1. 将服务器代码保存为 Python 包\n2. 在 `mcp.json` 中配置：\n\n```json\n{\n  \"mcpServers\": {\n    \"my-custom-server\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/mcp_server.py\"],\n      \"disabled\": false,\n      \"autoApprove\": [\"get_project_info\", \"analyze_code\"]\n    }\n  }\n}\n```\n\n## 实际应用场景\n\n### 场景 1：代码分析和优化\n\n```json\n{\n  \"mcpServers\": {\n    \"code-analyzer\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-code-analyzer\"],\n      \"disabled\": false,\n      \"autoApprove\": [\"analyze_complexity\", \"find_issues\"]\n    }\n  }\n}\n```\n\n**使用**：\n\n```\n你：@code-analyzer 分析这个函数的复杂度\n\nAI：根据代码分析，这个函数的圈复杂度是 8，建议拆分为更小的函数...\n```\n\n### 场景 2：文档生成\n\n```json\n{\n  \"mcpServers\": {\n    \"doc-generator\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-doc-generator\"],\n      \"disabled\": false,\n      \"autoApprove\": [\"generate_api_docs\", \"generate_readme\"]\n    }\n  }\n}\n```\n\n**使用**：\n\n```\n你：@doc-generator 为这个 API 生成文档\n\nAI：我将为你的 API 生成完整的文档，包括端点、参数和示例...\n```\n\n### 场景 3：部署和监控\n\n```json\n{\n  \"mcpServers\": {\n    \"deployment\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-deployment\"],\n      \"env\": {\n        \"DEPLOY_TOKEN\": \"your-token\"\n      },\n      \"disabled\": false,\n      \"autoApprove\": [\"check_deployment_status\", \"view_logs\"]\n    }\n  }\n}\n```\n\n**使用**：\n\n```\n你：@deployment 检查生产环境的部署状态\n\nAI：根据部署系统，你的应用已成功部署到生产环境...\n```\n\n### 场景 4：知识库集成\n\n```json\n{\n  \"mcpServers\": {\n    \"knowledge-base\": {\n      \"command\": \"uvx\",\n      \"args",
    "chapterId": "03-advanced",
    "tags": [
      "MCP",
      "集成",
      "工具",
      "进阶功能"
    ],
    "level": "advanced"
  },
  {
    "id": "03-advanced-specs",
    "title": "Specs 工作流程",
    "content": "\n# Specs 工作流程\n\nSpecs 是 Claude Code 的一个强大功能，它允许你创建结构化的规范文档来指导 AI 完成复杂的开发任务。通过 Specs，你可以定义项目需求、设计决策和实现细节，让 AI 更好地理解你的意图并生成高质量的代码。\n\n## 什么是 Specs？\n\nSpecs 是一种结构化的文档格式，用于定义软件项目的需求和实现计划。它包含：\n\n- **项目概述**：项目的目标和范围\n- **需求定义**：功能需求和非功能需求\n- **设计规范**：架构设计和技术选择\n- **实现计划**：分步骤的实现任务\n- **测试策略**：测试计划和验收标准\n\n## Specs 的优势\n\n### 1. 清晰的需求定义\n\n通过 Specs，你可以明确定义项目的需求，避免歧义和误解。\n\n### 2. 更好的 AI 理解\n\nAI 能够理解完整的项目上下文，生成更符合需求的代码。\n\n### 3. 可追踪的进度\n\nSpecs 中的任务列表可以帮助你追踪项目进度。\n\n### 4. 团队协作\n\nSpecs 可以作为团队成员之间的沟通工具，确保所有人对项目有相同的理解。\n\n## 创建 Specs 文档\n\n### 基本结构\n\n一个典型的 Specs 文档包含以下部分：\n\n```markdown\n# 项目名称\n\n## 项目概述\n\n简要描述项目的目标和范围。\n\n## 需求\n\n### 功能需求\n\n列出所有功能需求。\n\n### 非功能需求\n\n列出性能、安全性等非功能需求。\n\n## 设计\n\n### 架构设计\n\n描述系统架构。\n\n### 技术栈\n\n列出使用的技术和框架。\n\n## 实现计划\n\n### 第一阶段\n\n描述第一阶段的任务。\n\n### 第二阶段\n\n描述第二阶段的任务。\n\n## 测试策略\n\n描述测试计划和验收标准。\n```\n\n### 实际示例\n\n让我们创建一个真实的 Specs 文档示例：\n\n```markdown\n# 用户管理系统\n\n## 项目概述\n\n构建一个完整的用户管理系统，包括用户注册、登录、个人资料管理和权限控制。\n\n**目标**：\n- 提供安全的用户认证\n- 支持用户个人资料管理\n- 实现基于角色的访问控制（RBAC）\n- 提供用户管理的后台界面\n\n**范围**：\n- 前端：React + TypeScript\n- 后端：Node.js + Express\n- 数据库：PostgreSQL\n- 认证：JWT\n\n## 需求\n\n### 功能需求\n\n1. **用户认证**\n   - 用户注册（邮箱、密码）\n   - 用户登录（邮箱、密码）\n   - 密码重置功能\n   - 邮箱验证\n\n2. **用户管理**\n   - 查看个人资料\n   - 编辑个人资料（名字、头像、生物）\n   - 修改密码\n   - 删除账户\n\n3. **权限管理**\n   - 定义用户角色（管理员、编辑、查看者）\n   - 为用户分配角色\n   - 基于角色的访问控制\n\n4. **后台管理**\n   - 查看所有用户列表\n   - 搜索和过滤用户\n   - 禁用/启用用户账户\n   - 查看用户活动日志\n\n### 非功能需求\n\n- **性能**：API 响应时间 < 200ms\n- **安全性**：密码加密、SQL 注入防护、CSRF 防护\n- **可用性**：支持移动端、响应式设计\n- **可扩展性**：支持至少 10,000 并发用户\n\n## 设计\n\n### 架构设计\n\n```\n┌─────────────────┐\n│   React 前端    │\n└────────┬────────┘\n         │ HTTP/REST\n┌────────▼────────┐\n│  Express 后端   │\n└────────┬────────┘\n         │ SQL\n┌────────▼────────┐\n│   PostgreSQL    │\n└─────────────────┘\n```\n\n### 技术栈\n\n- **前端**：React 18, TypeScript, Tailwind CSS, React Router\n- **后端**：Node.js, Express, JWT, bcrypt\n- **数据库**：PostgreSQL, Sequelize ORM\n- **测试**：Jest, React Testing Library\n- **部署**：Docker, GitHub Actions\n\n### 数据模型\n\n```typescript\n// User 表\ninterface User {\n  id: string;\n  email: string;\n  password: string; // 加密后\n  name: string;\n  avatar?: string;\n  bio?: string;\n  role: 'admin' | 'editor' | 'viewer';\n  isActive: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Session 表\ninterface Session {\n  id: string;\n  userId: string;\n  token: string;\n  expiresAt: Date;\n  createdAt: Date;\n}\n```\n\n## 实现计划\n\n### 第一阶段：后端基础设施（第 1-2 周）\n\n- [ ] 设置 Express 项目和数据库连接\n- [ ] 实现用户模型和数据库迁移\n- [ ] 实现用户注册 API\n- [ ] 实现用户登录 API\n- [ ] 实现 JWT 认证中间件\n- [ ] 编写单元测试\n\n### 第二阶段：用户管理功能（第 3-4 周）\n\n- [ ] 实现获取用户资料 API\n- [ ] 实现编辑用户资料 API\n- [ ] 实现修改密码 API\n- [ ] 实现删除账户 API\n- [ ] 实现邮箱验证功能\n- [ ] 编写集成测试\n\n### 第三阶段：权限管理（第 5 周）\n\n- [ ] 实现角色管理 API\n- [ ] 实现权限检查中间件\n- [ ] 实现用户角色分配 API\n- [ ] 编写权限测试\n\n### 第四阶段：前端开发（第 6-8 周）\n\n- [ ] 创建项目结构和路由\n- [ ] 实现登录页面\n- [ ] 实现注册页面\n- [ ] 实现用户资料页面\n- [ ] 实现后台管理界面\n- [ ] 集成 API 调用\n\n### 第五阶段：测试和部署（第 9-10 周）\n\n- [ ] 完整的端到端测试\n- [ ] 性能测试和优化\n- [ ] 安全审计\n- [ ] Docker 容器化\n- [ ] 部署到生产环境\n\n## 测试策略\n\n### 单元测试\n\n- 用户模型的验证逻辑\n- 密码加密和验证\n- JWT 令牌生成和验证\n\n### 集成测试\n\n- 用户注册流程\n- 用户登录流程\n- 权限检查流程\n\n### 端到端测试\n\n- 完整的用户注册和登录流程\n- 用户资料编辑流程\n- 后台管理操作流程\n\n### 验收标准\n\n- 所有 API 端点都有相应的测试\n- 测试覆盖率 > 80%\n- 所有安全检查都已实现\n- 性能指标达到要求\n\n## 参考资源\n\n- [Express 官方文档](https://expressjs.com/)\n- [React 官方文档](https://react.dev/)\n- [PostgreSQL 官方文档](https://www.postgresql.org/docs/)\n- [JWT 认证最佳实践](https://tools.ietf.org/html/rfc7519)\n```\n\n## 使用 Specs 与 Claude Code\n\n### 步骤 1：创建 Specs 文档\n\n1. 在项目中创建 `.kiro/specs/` 目录\n2. 创建 `project-name.md` 文件\n3. 编写详细的 Specs 文档\n\n### 步骤 2：在 Chat 中引用 Specs\n\n在 Claude Code 的 Chat 中，你可以引用 Specs 文档：\n\n```\n你：根据 #specs/user-management 中的规范，实现用户注册 API\n\nAI：我已经阅读了 Specs 文档。我将按照以下步骤实现用户注册 API：\n1. 验证邮箱和密码\n2. 检查邮箱是否已存在\n3. 加密密码\n4. 创建用户记录\n5. 返回 JWT 令牌\n\n[AI 生成完整的代码实现]\n```\n\n### 步骤 3：追踪实现进度\n\n在 Specs 中更新任务完成状态：\n\n```markdown\n### 第一阶段：后端基础设施\n\n- [x] 设置 Express 项目和数据库连接\n- [x] 实现用户模型和数据库迁移\n- [x] 实现用户注册 API\n- [ ] 实现用户登录 API\n- [ ] 实现 JWT 认证中间件\n- [ ] 编写单元测试\n```\n\n## Specs 最佳实践\n\n### 1. 清晰的需求定义\n\n- 使用具体的、可测量的需求\n- 避免模糊的表述\n- 包含验收标准\n\n### 2. 详细的设计文档\n\n- 描述系统架构\n- 列出技术栈\n- 定义数据模型\n\n### 3. 可行的实现计划\n\n- 将大任务分解为小任务\n- 估计每个任务的工作量\n- 定义任务之间的依赖关系\n\n### 4. 清晰的测试策略\n\n- 定义测试类型（单元、集成、端到端）\n- 列出验收标准\n- 定义测试覆盖率目标\n\n### 5. 定期更新\n\n- 根据实际进度更新 Specs\n- 记录设计决策的变更\n- 保持文档与代码同步\n\n## 实际案例\n\n### 案例：电商平台开发\n\n使用 Specs 来管理一个复杂的电商平台项目：\n\n```markdown\n# 电商平台\n\n## 项目概述\n\n构建一个完整的电商平台，包括商品管理、购物车、订单管理和支付功能。\n\n## 需求\n\n### 功能需求\n\n1. **商品管理**\n   - 浏览商品列表\n   - 搜索和过滤商品\n   - 查看商品详情\n   - 添加商品到购物车\n\n2. **购物车**\n   - 查看购物车\n   - 修改商品数量\n   - 删除商品\n   - 计算总价\n\n3. **订单管理**\n   - 创建订单\n   - 查看订单历史\n   - 追踪订单状态\n   - 取消订单\n\n4. **支付**\n   - 集成支付网关\n   - 处理支付回调\n   - 生成发票\n\n## 实现计划\n\n### 第一阶段：商品管理（第 1-2 周）\n\n- [ ] 设计商品数据模型\n- [ ] 实现商品 API\n- [ ] 创建商品列表页面\n- [ ] 实现搜索和过滤\n\n### 第二阶段：购物车（第 3 周）\n\n- [ ] 实现购物车 API\n- [ ] 创建购物车页面\n- [ ] 实现购物车逻辑\n\n### 第三阶段：订单和支付（第 4-5 周）\n\n- [ ] 实现订单 API\n- [ ] 集成支付网关\n- [ ] 创建订单页面\n\n### 第四阶段：测试和优化（第 6 周）\n\n- [ ] 完整测试\n- [ ] 性能优化\n- [ ] 部署\n```\n\n## 常见问题\n\n### Q: Specs 应该有多详细？\n\n**A:** Specs 应该包含足够的细节让 AI 理解你的需求，但不需要过度详细。通常 2-5 页的文档就足够了。\n\n### Q: 如何在团队中使用 Specs？\n\n**A:** 将 Specs 文档存储在版本控制系统中，团队成员可以一起编辑和讨论。\n\n### Q: Specs 可以在项目进行中修改吗？\n\n**A:** 完全可以。Specs 应该随着项目的进展而更新，记录设计决策的变更。\n\n### Q: 如何将 Specs 与代码关联？\n\n**A:** 在代码注释中引用 Specs 中的相关部分，例如 `// 参见 Specs: ",
    "chapterId": "03-advanced",
    "tags": [
      "Specs",
      "工作流程",
      "项目管理",
      "进阶功能"
    ],
    "level": "advanced"
  },
  {
    "id": "03-advanced-steering",
    "title": "Steering 配置指南",
    "content": "\n# Steering 配置指南\n\nSteering 是 Claude Code 的一个高级功能，它允许你为团队定制 AI 的行为、建议和输出。通过 Steering，你可以确保 AI 遵循团队的编码规范、最佳实践和项目特定的要求。\n\n## 什么是 Steering？\n\nSteering 是一组配置规则，用于指导 Claude Code 的 AI 如何理解和响应你的请求。它包括：\n\n- **编码规范**：命名约定、代码风格、项目结构\n- **最佳实践**：设计模式、性能优化、安全性要求\n- **项目特定规则**：技术栈、依赖项、特殊要求\n- **团队指南**：沟通风格、文档标准、审查流程\n\n## Steering 的优势\n\n### 1. 一致的代码风格\n\n确保 AI 生成的代码与团队的编码规范一致。\n\n### 2. 更好的建议\n\nAI 能够理解团队的特定需求和偏好，提供更相关的建议。\n\n### 3. 知识共享\n\n将团队的最佳实践和经验编码到 Steering 中，新成员可以快速学习。\n\n### 4. 自动化合规性\n\n确保所有代码都遵循团队的规范和最佳实践。\n\n## 创建 Steering 文件\n\n### 基本结构\n\nSteering 文件位于 `.kiro/steering/` 目录中，使用 Markdown 格式：\n\n```markdown\n---\ninclusion: always  # always, fileMatch, manual\nfileMatchPattern: \"src/**/*.ts\"  # 可选，用于 fileMatch\n---\n\n# 团队编码规范\n\n## 命名约定\n\n- 变量和函数：camelCase\n- 类和接口：PascalCase\n- 常量：UPPER_SNAKE_CASE\n- 文件名：kebab-case（除了组件）\n\n## 代码风格\n\n- 使用 2 个空格缩进\n- 行长度限制：100 字符\n- 使用分号\n- 使用单引号\n\n## 最佳实践\n\n- 始终添加类型注解\n- 编写单元测试\n- 添加 JSDoc 注释\n```\n\n### 实际示例\n\n让我们创建一个完整的 Steering 文件：\n\n```markdown\n---\ninclusion: always\n---\n\n# 我们的编码规范\n\n## 项目概述\n\n这是一个 React + TypeScript 的前端项目。我们遵循以下规范来确保代码质量和一致性。\n\n## 技术栈\n\n- **框架**：React 18+\n- **语言**：TypeScript 5+\n- **样式**：Tailwind CSS\n- **状态管理**：Zustand\n- **测试**：Jest + React Testing Library\n- **构建工具**：Vite\n\n## 命名约定\n\n### 文件和文件夹\n\n- 组件文件：PascalCase（`UserProfile.tsx`）\n- 工具函数：camelCase（`formatDate.ts`）\n- 样式文件：kebab-case（`user-profile.css`）\n- 测试文件：`*.test.ts` 或 `*.spec.ts`\n- 文件夹：kebab-case（`user-profile/`）\n\n### 代码\n\n- 变量和函数：camelCase\n- 类和接口：PascalCase\n- 常量：UPPER_SNAKE_CASE\n- 私有属性：前缀 `_`\n- 布尔变量：前缀 `is`, `has`, `can`\n\n### 示例\n\n```typescript\n// ✅ 好的命名\nconst MAX_RETRIES = 3;\nconst isLoading = false;\nconst getUserById = (id: string) => { ... };\ninterface UserProfile { ... }\nclass UserService { ... }\n\n// ❌ 不好的命名\nconst max_retries = 3;\nconst loading = false;\nconst get_user_by_id = (id: string) => { ... };\ninterface userProfile { ... }\nclass userService { ... }\n```\n\n## 代码风格\n\n### 缩进和格式\n\n- 使用 2 个空格缩进（不使用 Tab）\n- 行长度限制：100 字符\n- 使用分号\n- 使用单引号（字符串）\n- 使用双引号（JSX 属性）\n\n### 导入顺序\n\n```typescript\n// 1. 外部库\nimport React from 'react';\nimport { useEffect } from 'react';\n\n// 2. 内部模块\nimport { UserService } from '@/services';\nimport { useUserStore } from '@/store';\n\n// 3. 组件\nimport { UserCard } from '@/components';\n\n// 4. 样式\nimport styles from './User.module.css';\n```\n\n### 类型注解\n\n始终为函数参数和返回值添加类型注解：\n\n```typescript\n// ✅ 好的\nfunction getUserById(id: string): Promise<User> {\n  return fetch(`/api/users/${id}`).then(r => r.json());\n}\n\n// ❌ 不好的\nfunction getUserById(id) {\n  return fetch(`/api/users/${id}`).then(r => r.json());\n}\n```\n\n## React 组件规范\n\n### 组件结构\n\n```typescript\nimport React, { FC, useState } from 'react';\nimport styles from './UserProfile.module.css';\n\ninterface UserProfileProps {\n  userId: string;\n  onUpdate?: (user: User) => void;\n}\n\n/**\n * 用户资料组件\n * \n * @param userId - 用户 ID\n * @param onUpdate - 用户更新时的回调\n */\nexport const UserProfile: FC<UserProfileProps> = ({ userId, onUpdate }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  // 逻辑代码\n\n  return (\n    <div className={styles.container}>\n      {/* JSX */}\n    </div>\n  );\n};\n```\n\n### 组件最佳实践\n\n- 使用函数组件和 Hooks\n- 使用 TypeScript 接口定义 Props\n- 添加 JSDoc 注释\n- 使用 `FC` 类型注解\n- 避免内联样式，使用 CSS 模块或 Tailwind\n- 提取复杂逻辑到自定义 Hooks\n\n## 测试规范\n\n### 测试文件位置\n\n- 单元测试：`src/__tests__/` 或 `src/**/*.test.ts`\n- 集成测试：`src/__tests__/integration/`\n- 端到端测试：`e2e/`\n\n### 测试覆盖率\n\n- 最小覆盖率：80%\n- 关键路径：100%\n- 工具函数：100%\n\n### 测试示例\n\n```typescript\nimport { render, screen } from '@testing-library/react';\nimport { UserProfile } from './UserProfile';\n\ndescribe('UserProfile', () => {\n  it('should render user name', () => {\n    const mockUser = { id: '1', name: 'Alice' };\n    render(<UserProfile userId=\"1\" />);\n    \n    expect(screen.getByText('Alice')).toBeInTheDocument();\n  });\n\n  it('should call onUpdate when user is updated', () => {\n    const onUpdate = jest.fn();\n    render(<UserProfile userId=\"1\" onUpdate={onUpdate} />);\n    \n    // 触发更新\n    // 验证 onUpdate 被调用\n    expect(onUpdate).toHaveBeenCalled();\n  });\n});\n```\n\n## 文档规范\n\n### JSDoc 注释\n\n为所有导出的函数、类和接口添加 JSDoc 注释：\n\n```typescript\n/**\n * 获取用户信息\n * \n * @param userId - 用户 ID\n * @returns 用户对象\n * @throws 如果用户不存在\n * \n * @example\n * const user = await getUser('123');\n */\nexport async function getUser(userId: string): Promise<User> {\n  // ...\n}\n```\n\n### README 文档\n\n每个主要模块应该有 README 文件，包含：\n\n- 模块的目的\n- 主要功能\n- 使用示例\n- API 文档\n\n## 性能指南\n\n### 优化建议\n\n- 使用 React.memo 避免不必要的重新渲染\n- 使用 useMemo 和 useCallback 优化性能\n- 代码分割和懒加载\n- 图片优化和压缩\n- 避免在渲染中创建新对象\n\n### 性能指标\n\n- 首屏加载时间：< 3 秒\n- 交互时间：< 100ms\n- 最大内容绘制：< 2.5 秒\n\n## 安全性指南\n\n### 常见安全问题\n\n- 避免 XSS 攻击：不要使用 `dangerouslySetInnerHTML`\n- 避免 CSRF 攻击：使用 CSRF 令牌\n- 验证用户输入\n- 不要在代码中硬编码敏感信息\n- 使用 HTTPS\n\n### 安全检查清单\n\n- [ ] 所有用户输入都已验证\n- [ ] 敏感数据已加密\n- [ ] 没有硬编码的密钥或令牌\n- [ ] 依赖项已更新到最新版本\n- [ ] 已运行安全审计工具\n\n## 提交和审查流程\n\n### 提交消息格式\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n类型：\n- `feat`: 新功能\n- `fix`: 修复 bug\n- `docs`: 文档更新\n- `style`: 代码风格\n- `refactor`: 代码重构\n- `test`: 测试\n- `chore`: 构建、依赖等\n\n### 示例\n\n```\nfeat(user): add user profile page\n\n- Create UserProfile component\n- Add user d",
    "chapterId": "03-advanced",
    "tags": [
      "Steering",
      "配置",
      "团队协作",
      "进阶功能"
    ],
    "level": "advanced"
  },
  {
    "id": "04-mastery-advanced-tips",
    "title": "高级技巧和快捷键大全",
    "content": "\n# 高级技巧和快捷键大全\n\n本章节介绍 Claude Code 的高级功能和快捷键，帮助你充分利用这个强大的工具，大幅提升开发效率。\n\n## 快捷键大全\n\n### 编辑器快捷键\n\n#### 基础编辑\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Ctrl+Z` / `Cmd+Z` | 撤销 | 撤销上一步操作 |\n| `Ctrl+Shift+Z` / `Cmd+Shift+Z` | 重做 | 重做上一步撤销 |\n| `Ctrl+X` / `Cmd+X` | 剪切 | 剪切选中内容 |\n| `Ctrl+C` / `Cmd+C` | 复制 | 复制选中内容 |\n| `Ctrl+V` / `Cmd+V` | 粘贴 | 粘贴剪贴板内容 |\n| `Ctrl+Shift+V` / `Cmd+Shift+V` | 粘贴为纯文本 | 粘贴不带格式的文本 |\n| `Ctrl+A` / `Cmd+A` | 全选 | 选中所有内容 |\n| `Ctrl+D` / `Cmd+D` | 选择单词 | 选中光标处的单词 |\n\n#### 行操作\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Ctrl+Shift+K` / `Cmd+Shift+K` | 删除行 | 删除当前行 |\n| `Ctrl+Shift+Enter` / `Cmd+Shift+Enter` | 在上方插入行 | 在当前行上方插入新行 |\n| `Ctrl+Enter` / `Cmd+Enter` | 在下方插入行 | 在当前行下方插入新行 |\n| `Alt+↑` / `Option+↑` | 向上移动行 | 将当前行向上移动 |\n| `Alt+↓` / `Option+↓` | 向下移动行 | 将当前行向下移动 |\n| `Alt+Shift+↑` / `Option+Shift+↑` | 向上复制行 | 复制当前行到上方 |\n| `Alt+Shift+↓` / `Option+Shift+↓` | 向下复制行 | 复制当前行到下方 |\n\n#### 选择和多光标\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Ctrl+L` / `Cmd+L` | 选择行 | 选中当前行 |\n| `Ctrl+Shift+L` / `Cmd+Shift+L` | 选择所有匹配项 | 选中所有匹配的单词 |\n| `Ctrl+F2` / `Cmd+F2` | 选择所有出现 | 选中所有出现的单词 |\n| `Ctrl+Alt+↑` / `Cmd+Option+↑` | 向上添加光标 | 在上方添加光标 |\n| `Ctrl+Alt+↓` / `Cmd+Option+↓` | 向下添加光标 | 在下方添加光标 |\n\n### 导航快捷键\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Ctrl+P` / `Cmd+P` | 快速打开文件 | 按名称快速打开文件 |\n| `Ctrl+G` / `Cmd+G` | 转到行 | 跳转到指定行号 |\n| `Ctrl+Shift+O` / `Cmd+Shift+O` | 转到符号 | 跳转到文件中的符号 |\n| `Ctrl+T` / `Cmd+T` | 转到工作区符号 | 跳转到工作区中的符号 |\n| `Ctrl+Home` / `Cmd+Home` | 转到文件开头 | 跳转到文件开头 |\n| `Ctrl+End` / `Cmd+End` | 转到文件末尾 | 跳转到文件末尾 |\n| `Ctrl+K Ctrl+I` / `Cmd+K Cmd+I` | 显示悬停信息 | 显示光标处的类型信息 |\n\n### 搜索和替换\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Ctrl+F` / `Cmd+F` | 查找 | 在当前文件中查找 |\n| `Ctrl+H` / `Cmd+H` | 查找和替换 | 在当前文件中查找和替换 |\n| `Ctrl+Shift+F` / `Cmd+Shift+F` | 全局查找 | 在所有文件中查找 |\n| `Ctrl+Shift+H` / `Cmd+Shift+H` | 全局替换 | 在所有文件中查找和替换 |\n| `F3` / `F3` | 查找下一个 | 查找下一个匹配项 |\n| `Shift+F3` / `Shift+F3` | 查找上一个 | 查找上一个匹配项 |\n\n### Claude Code 特定快捷键\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Ctrl+L` / `Cmd+L` | 打开 Chat | 打开 Claude Code Chat 面板 |\n| `Ctrl+Shift+C` / `Cmd+Shift+C` | 打开 Chat | 打开 Claude Code Chat 面板 |\n| `Ctrl+K` / `Cmd+K` | 快速搜索 | 快速搜索功能 |\n| `Tab` | 接受补全 | 接受 AI 代码补全建议 |\n| `Ctrl+→` / `Cmd+→` | 接受下一个词 | 逐词接受补全建议 |\n| `Esc` | 取消补全 | 取消当前补全建议 |\n\n### 面板快捷键\n\n| 快捷键 | 功能 | 说明 |\n|--------|------|------|\n| `Ctrl+B` / `Cmd+B` | 切换侧边栏 | 显示/隐藏左侧边栏 |\n| `Ctrl+J` / `Cmd+J` | 切换面板 | 显示/隐藏底部面板 |\n| `Ctrl+Shift+E` / `Cmd+Shift+E` | 打开文件浏览器 | 打开文件浏览器面板 |\n| `Ctrl+Shift+G` / `Cmd+Shift+G` | 打开 Git | 打开 Git 面板 |\n| `Ctrl+Shift+D` / `Cmd+Shift+D` | 打开调试器 | 打开调试器面板 |\n| `Ctrl+Shift+X` / `Cmd+Shift+X` | 打开扩展 | 打开扩展面板 |\n\n## 高级编辑技巧\n\n### 1. 多光标编辑\n\n#### 场景：同时编辑多个位置\n\n```typescript\n// 原始代码\nconst user1 = getUserData(1);\nconst user2 = getUserData(2);\nconst user3 = getUserData(3);\n\n// 使用多光标编辑\n// 1. 选中第一个 getUserData\n// 2. Ctrl+D 选择下一个匹配项\n// 3. 继续 Ctrl+D 选择所有匹配项\n// 4. 现在可以同时编辑所有匹配项\n\n// 结果\nconst user1 = fetchUserData(1);\nconst user2 = fetchUserData(2);\nconst user3 = fetchUserData(3);\n```\n\n### 2. 列选择\n\n#### 场景：编辑多行的特定列\n\n```typescript\n// 原始代码\nconst firstName = 'John';\nconst lastName = 'Doe';\nconst email = 'john@example.com';\n\n// 使用列选择\n// 1. 点击第一行的 'const'\n// 2. Shift+Alt+↓ 向下扩展选择\n// 3. 现在可以同时编辑所有行的 'const'\n\n// 结果\nlet firstName = 'John';\nlet lastName = 'Doe';\nlet email = 'john@example.com';\n```\n\n### 3. 代码折叠\n\n#### 快捷键\n\n| 快捷键 | 功能 |\n|--------|------|\n| `Ctrl+Shift+[` / `Cmd+Option+[` | 折叠区域 |\n| `Ctrl+Shift+]` / `Cmd+Option+]` | 展开区域 |\n| `Ctrl+K Ctrl+0` / `Cmd+K Cmd+0` | 折叠所有 |\n| `Ctrl+K Ctrl+J` / `Cmd+K Cmd+J` | 展开所有 |\n\n### 4. 代码格式化\n\n```typescript\n// 格式化快捷键\n// Shift+Alt+F / Shift+Option+F - 格式化文档\n// Ctrl+K Ctrl+F / Cmd+K Cmd+F - 格式化选中代码\n\n// 示例：格式化前\nfunction foo(){const x=1;return x;}\n\n// 格式化后\nfunction foo() {\n  const x = 1;\n  return x;\n}\n```\n\n## 高级搜索技巧\n\n### 1. 正则表达式搜索\n\n```\n// 搜索所有 console.log 语句\n搜索: console\\.log\\(.*\\)\n替换: // 已删除\n\n// 搜索所有 TODO 注释\n搜索: //\\s*TODO:.*\n```\n\n### 2. 高级查找选项\n\n- **区分大小写**：`Aa` 按钮\n- **全字匹配**：`Ab` 按钮\n- **正则表达式**：`.*` 按钮\n\n### 3. 搜索范围限制\n\n```\n// 在特定文件中搜索\n搜索: 搜索词\n包含: src/**/*.ts\n排除: src/**/*.test.ts\n```\n\n## 高级 Chat 技巧\n\n### 1. 上下文引用\n\n```\n你：@UserService 这个类中的 createUser 方法有什么问题？\n\nAI：我看到了 UserService 类。让我分析 createUser 方法...\n```\n\n### 2. 文件选择\n\n```\n你：[选中 UserService.ts 中的 createUser 方法]\n请为这个方法添加错误处理\n\nAI：我会为 createUser 方法添加完整的错误处理...\n```\n\n### 3. 对话历史\n\n- 向上/向下箭头：浏览对话历史\n- `Ctrl+L` / `Cmd+L`：清除当前对话\n\n## 性能优化技巧\n\n### 1. 代码分割\n\n```typescript\n// 使用动态导入进行代码分割\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\n// 在 React 中使用\n<Suspense fallback={<Loading />}>\n  <HeavyComponent />\n</Suspense>\n```\n\n### 2. 懒加载\n\n```typescript\n// 图片懒加载\n<img src=\"image.jpg\" loading=\"lazy\" />\n\n// 组件懒加载\nconst Component = lazy(() => import('./Component'));\n```\n\n### 3. 缓存策略\n\n```typescript\n// 使用 useMemo 缓存计算结果\nconst memoizedValue = useMemo(() => {\n  return expensiveCalculation(a, b);\n}, [a, b]);\n\n// 使用 useCallback 缓存函数\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n```\n\n## 调试技巧\n\n### 1. 断点调试\n\n```typescript\n// 设置断点\n// 1. 点击行号左侧\n// 2. 或使用 debugger 语句\ndebugger;\n\n/",
    "chapterId": "04-mastery",
    "tags": [
      "高级技巧",
      "快捷键",
      "效率",
      "精通"
    ],
    "level": "expert"
  },
  {
    "id": "04-mastery-best-practices",
    "title": "最佳实践指南",
    "content": "\n# 最佳实践指南\n\n本章节深入探讨编程最佳实践，帮助你避免常见陷阱，提高代码质量和开发效率。这些实践基于多年的行业经验和最新的技术趋势。\n\n## 代码质量最佳实践\n\n### 1. 清晰的代码结构\n\n#### 原则\n\n代码应该像讲故事一样清晰易懂。优先考虑可读性而不是简洁性。\n\n#### 好的实践\n\n```typescript\n// ✅ 清晰的代码结构\nclass UserService {\n  private userRepository: UserRepository;\n  private emailService: EmailService;\n\n  constructor(userRepository: UserRepository, emailService: EmailService) {\n    this.userRepository = userRepository;\n    this.emailService = emailService;\n  }\n\n  /**\n   * 创建新用户并发送欢迎邮件\n   */\n  async createUserWithWelcomeEmail(userData: CreateUserDTO): Promise<User> {\n    // 验证输入\n    this.validateUserData(userData);\n\n    // 创建用户\n    const user = await this.userRepository.create(userData);\n\n    // 发送欢迎邮件\n    await this.emailService.sendWelcomeEmail(user.email);\n\n    return user;\n  }\n\n  private validateUserData(data: CreateUserDTO): void {\n    if (!data.email || !data.name) {\n      throw new Error('Email and name are required');\n    }\n  }\n}\n```\n\n#### 常见陷阱\n\n```typescript\n// ❌ 混乱的代码结构\nclass US {\n  ur: UR;\n  es: ES;\n  c(d) {\n    if (!d.e || !d.n) throw new Error('E');\n    const u = this.ur.c(d);\n    this.es.s(u.e);\n    return u;\n  }\n}\n```\n\n### 2. 单一职责原则（SRP）\n\n#### 原则\n\n每个类或函数应该只有一个改变的理由。\n\n#### 好的实践\n\n```typescript\n// ✅ 遵循 SRP\nclass UserValidator {\n  validate(user: User): ValidationResult {\n    // 只负责验证\n    return {\n      isValid: user.email && user.name,\n      errors: []\n    };\n  }\n}\n\nclass UserRepository {\n  async create(user: User): Promise<User> {\n    // 只负责数据持久化\n    return await db.users.insert(user);\n  }\n}\n\nclass UserService {\n  constructor(\n    private validator: UserValidator,\n    private repository: UserRepository\n  ) {}\n\n  async createUser(userData: CreateUserDTO): Promise<User> {\n    // 协调验证和持久化\n    const validation = this.validator.validate(userData);\n    if (!validation.isValid) {\n      throw new Error(validation.errors.join(', '));\n    }\n    return await this.repository.create(userData);\n  }\n}\n```\n\n#### 常见陷阱\n\n```typescript\n// ❌ 违反 SRP\nclass UserManager {\n  // 混合了验证、持久化、邮件发送等多个职责\n  async createUser(userData) {\n    // 验证\n    if (!userData.email) throw new Error('Email required');\n    \n    // 持久化\n    const user = await db.users.insert(userData);\n    \n    // 发送邮件\n    await sendEmail(user.email);\n    \n    // 记录日志\n    console.log('User created:', user.id);\n    \n    // 更新缓存\n    cache.set(`user:${user.id}`, user);\n    \n    return user;\n  }\n}\n```\n\n### 3. DRY 原则（Don't Repeat Yourself）\n\n#### 原则\n\n避免重复代码，提取公共逻辑。\n\n#### 好的实践\n\n```typescript\n// ✅ 提取公共逻辑\nfunction formatDate(date: Date, format: string): string {\n  // 统一的日期格式化逻辑\n  return new Intl.DateTimeFormat('zh-CN', {\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit'\n  }).format(date);\n}\n\n// 在多个地方使用\nconst createdDate = formatDate(user.createdAt, 'YYYY-MM-DD');\nconst updatedDate = formatDate(user.updatedAt, 'YYYY-MM-DD');\n```\n\n#### 常见陷阱\n\n```typescript\n// ❌ 重复的代码\nfunction getUserInfo(userId: string) {\n  const user = await fetch(`/api/users/${userId}`).then(r => r.json());\n  const formatted = new Intl.DateTimeFormat('zh-CN').format(user.createdAt);\n  return { ...user, createdAt: formatted };\n}\n\nfunction getPostInfo(postId: string) {\n  const post = await fetch(`/api/posts/${postId}`).then(r => r.json());\n  const formatted = new Intl.DateTimeFormat('zh-CN').format(post.createdAt);\n  return { ...post, createdAt: formatted };\n}\n```\n\n## 性能最佳实践\n\n### 1. 避免 N+1 查询\n\n#### 问题\n\n```typescript\n// ❌ N+1 查询问题\nasync function getUsersWithPosts(userIds: string[]) {\n  const users = await db.users.find({ id: { $in: userIds } });\n  \n  // 这会执行 N 次查询\n  const usersWithPosts = await Promise.all(\n    users.map(user => \n      db.posts.find({ userId: user.id })\n    )\n  );\n  \n  return usersWithPosts;\n}\n```\n\n#### 解决方案\n\n```typescript\n// ✅ 使用 JOIN 或批量查询\nasync function getUsersWithPosts(userIds: string[]) {\n  // 方案 1：使用 JOIN\n  const usersWithPosts = await db.query(`\n    SELECT u.*, p.* FROM users u\n    LEFT JOIN posts p ON u.id = p.userId\n    WHERE u.id IN (?)\n  `, [userIds]);\n  \n  // 方案 2：批量查询\n  const users = await db.users.find({ id: { $in: userIds } });\n  const posts = await db.posts.find({ userId: { $in: userIds } });\n  \n  return users.map(user => ({\n    ...user,\n    posts: posts.filter(p => p.userId === user.id)\n  }));\n}\n```\n\n### 2. 缓存策略\n\n#### 好的实践\n\n```typescript\n// ✅ 实现缓存\nclass UserService {\n  private cache = new Map<string, User>();\n  private cacheExpiry = new Map<string, number>();\n\n  async getUser(userId: string): Promise<User> {\n    // 检查缓存\n    if (this.cache.has(userId)) {\n      const expiry = this.cacheExpiry.get(userId);\n      if (expiry && expiry > Date.now()) {\n        return this.cache.get(userId)!;\n      }\n      // 缓存过期，删除\n      this.cache.delete(userId);\n      this.cacheExpiry.delete(userId);\n    }\n\n    // 从数据库获取\n    const user = await db.users.findById(userId);\n\n    // 缓存结果（5 分钟）\n    this.cache.set(userId, user);\n    this.cacheExpiry.set(userId, Date.now() + 5 * 60 * 1000);\n\n    return user;\n  }\n\n  invalidateCache(userId: string): void {\n    this.cache.delete(userId);\n    this.cacheExpiry.delete(user",
    "chapterId": "04-mastery",
    "tags": [
      "最佳实践",
      "编程规范",
      "效率",
      "精通"
    ],
    "level": "expert"
  },
  {
    "id": "04-mastery-real-world-projects",
    "title": "实战项目案例",
    "content": "\n# 实战项目案例\n\n本章节通过完整的实战项目案例，展示如何使用 Claude Code 开发真实应用。这些案例涵盖了从需求分析到部署的完整开发流程。\n\n## 项目 1：任务管理应用\n\n### 项目概述\n\n构建一个功能完整的任务管理应用，包括任务创建、编辑、删除、分类和搜索功能。\n\n### 技术栈\n\n- **前端**：React + TypeScript + Tailwind CSS\n- **状态管理**：Zustand\n- **存储**：LocalStorage\n- **测试**：Jest + React Testing Library\n\n### 项目结构\n\n```\ntodo-app/\n├── src/\n│   ├── components/\n│   │   ├── TaskForm.tsx\n│   │   ├── TaskList.tsx\n│   │   ├── TaskItem.tsx\n│   │   └── TaskFilter.tsx\n│   ├── store/\n│   │   └── taskStore.ts\n│   ├── types/\n│   │   └── task.ts\n│   ├── App.tsx\n│   └── index.css\n├── tests/\n│   ├── taskStore.test.ts\n│   └── TaskList.test.tsx\n└── package.json\n```\n\n### 核心实现\n\n#### 1. 类型定义\n\n```typescript\n// src/types/task.ts\nexport interface Task {\n  id: string;\n  title: string;\n  description?: string;\n  category: 'work' | 'personal' | 'shopping';\n  completed: boolean;\n  dueDate?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface TaskFilter {\n  category?: string;\n  completed?: boolean;\n  searchTerm?: string;\n}\n```\n\n#### 2. 状态管理\n\n```typescript\n// src/store/taskStore.ts\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { Task, TaskFilter } from '../types/task';\n\ninterface TaskStore {\n  tasks: Task[];\n  filter: TaskFilter;\n  \n  // 操作\n  addTask: (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>) => void;\n  updateTask: (id: string, updates: Partial<Task>) => void;\n  deleteTask: (id: string) => void;\n  toggleTask: (id: string) => void;\n  setFilter: (filter: TaskFilter) => void;\n  \n  // 查询\n  getFilteredTasks: () => Task[];\n}\n\nexport const useTaskStore = create<TaskStore>()(\n  persist(\n    (set, get) => ({\n      tasks: [],\n      filter: {},\n      \n      addTask: (task) => set((state) => ({\n        tasks: [\n          ...state.tasks,\n          {\n            ...task,\n            id: Date.now().toString(),\n            createdAt: new Date(),\n            updatedAt: new Date(),\n          }\n        ]\n      })),\n      \n      updateTask: (id, updates) => set((state) => ({\n        tasks: state.tasks.map(task =>\n          task.id === id\n            ? { ...task, ...updates, updatedAt: new Date() }\n            : task\n        )\n      })),\n      \n      deleteTask: (id) => set((state) => ({\n        tasks: state.tasks.filter(task => task.id !== id)\n      })),\n      \n      toggleTask: (id) => set((state) => ({\n        tasks: state.tasks.map(task =>\n          task.id === id\n            ? { ...task, completed: !task.completed }\n            : task\n        )\n      })),\n      \n      setFilter: (filter) => set({ filter }),\n      \n      getFilteredTasks: () => {\n        const { tasks, filter } = get();\n        return tasks.filter(task => {\n          if (filter.category && task.category !== filter.category) {\n            return false;\n          }\n          if (filter.completed !== undefined && task.completed !== filter.completed) {\n            return false;\n          }\n          if (filter.searchTerm) {\n            const term = filter.searchTerm.toLowerCase();\n            return (\n              task.title.toLowerCase().includes(term) ||\n              task.description?.toLowerCase().includes(term)\n            );\n          }\n          return true;\n        });\n      }\n    }),\n    {\n      name: 'task-store'\n    }\n  )\n);\n```\n\n#### 3. 组件实现\n\n```typescript\n// src/components/TaskList.tsx\nimport React from 'react';\nimport { useTaskStore } from '../store/taskStore';\nimport TaskItem from './TaskItem';\nimport TaskFilter from './TaskFilter';\n\nexport const TaskList: React.FC = () => {\n  const { getFilteredTasks } = useTaskStore();\n  const filteredTasks = getFilteredTasks();\n\n  return (\n    <div className=\"space-y-4\">\n      <TaskFilter />\n      \n      {filteredTasks.length === 0 ? (\n        <div className=\"text-center py-8 text-gray-500\">\n          没有找到任务\n        </div>\n      ) : (\n        <div className=\"space-y-2\">\n          {filteredTasks.map(task => (\n            <TaskItem key={task.id} task={task} />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n```\n\n### 常见问题和解决方案\n\n#### Q: 如何处理任务的持久化？\n\n**A:** 使用 Zustand 的 `persist` 中间件自动保存到 LocalStorage。\n\n#### Q: 如何实现搜索功能？\n\n**A:** 在 `getFilteredTasks` 中添加搜索逻辑，支持标题和描述的模糊搜索。\n\n#### Q: 如何测试异步操作？\n\n**A:** 使用 `jest.useFakeTimers()` 和 `waitFor` 来测试异步操作。\n\n## 项目 2：博客系统\n\n### 项目概述\n\n构建一个完整的博客系统，包括文章管理、评论系统、标签分类和搜索功能。\n\n### 技术栈\n\n- **前端**：React + TypeScript\n- **后端**：Node.js + Express\n- **数据库**：MongoDB\n- **认证**：JWT\n\n### 核心功能\n\n#### 1. 文章管理 API\n\n```typescript\n// backend/routes/articles.ts\nimport express from 'express';\nimport { Article } from '../models/Article';\nimport { authenticate } from '../middleware/auth';\n\nconst router = express.Router();\n\n// 获取所有文章\nrouter.get('/', async (req, res) => {\n  try {\n    const { page = 1, limit = 10, tag, search } = req.query;\n    \n    let query: any = { published: true };\n    \n    if (tag) {\n      query.tags = tag;\n    }\n    \n    if (search) {\n      query.$or = [\n        { title: { $regex: search, $options: 'i' } },\n        { content: { $regex: search, $options: 'i' } }\n      ];\n    }\n    \n",
    "chapterId": "04-mastery",
    "tags": [
      "实战",
      "项目案例",
      "完整示例",
      "精通"
    ],
    "level": "expert"
  }
]